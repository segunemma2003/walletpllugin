"use strict";
(this["webpackChunkpaycio_wallet"] = this["webpackChunkpaycio_wallet"] || []).push([["node_modules_ledgerhq_hw-transport-webusb_lib-es_TransportWebUSB_js"],{

/***/ "./node_modules/@ledgerhq/errors/lib-es/index.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ej: function() { return /* binding */ DisconnectedDevice; },
  iX: function() { return /* binding */ DisconnectedDeviceDuringOperation; },
  vi: function() { return /* binding */ StatusCodes; },
  wX: function() { return /* binding */ TransportError; },
  pi: function() { return /* binding */ TransportInterfaceNotAvailable; },
  kt: function() { return /* binding */ TransportOpenUserCancelled; },
  ug: function() { return /* binding */ TransportRaceCondition; },
  _3: function() { return /* binding */ TransportStatusError; },
  e0: function() { return /* binding */ TransportWebUSBGestureRequired; },
  Oq: function() { return /* reexport */ createCustomErrorClass; }
});

// UNUSED EXPORTS: AccountAwaitingSendPendingOperations, AccountNameRequiredError, AccountNotSupported, AmountRequired, BluetoothRequired, BtcUnmatchedApp, CantOpenDevice, CantScanQRCode, CashAddrNotSupported, ClaimRewardsFeesWarning, CurrencyNotSupported, DBNotReset, DBWrongPassword, DeviceAppVerifyNotSupported, DeviceExtractOnboardingStateError, DeviceGenuineSocketEarlyClose, DeviceHalted, DeviceInOSUExpected, DeviceMangementKitError, DeviceNameInvalid, DeviceNeedsRestart, DeviceNotGenuineError, DeviceOnDashboardExpected, DeviceOnDashboardUnexpected, DeviceOnboardingStatePollingError, DeviceShouldStayInApp, DeviceSocketFail, DeviceSocketNoBulkStatus, DisabledTransactionBroadcastError, DustLimit, ETHAddressNonEIP, EnpointConfigError, EthAppPleaseEnableContractData, ExpertModeRequired, FeeEstimationFailed, FeeNotLoaded, FeeNotLoadedSwap, FeeRequired, FeeTooHigh, FirmwareNotRecognized, FirmwareOrAppUpdateRequired, GasLessThanEstimate, GenuineCheckFailed, HardResetFail, HwTransportError, HwTransportErrorType, InvalidAddress, InvalidAddressBecauseDestinationIsAlsoSource, InvalidNonce, InvalidXRPTag, LanguageNotFound, LatestFirmwareVersionRequired, LatestMCUInstalledError, LedgerAPI4xx, LedgerAPI5xx, LedgerAPIError, LedgerAPIErrorWithMessage, LedgerAPINotAvailable, LockedDeviceError, MCUNotGenuineToDashboard, ManagerAppAlreadyInstalledError, ManagerAppDepInstallRequired, ManagerAppDepUninstallRequired, ManagerAppRelyOnBTCError, ManagerDeviceLockedError, ManagerFirmwareNotEnoughSpaceError, ManagerNotEnoughSpaceError, ManagerUninstallBTCDep, MaxFeeTooLow, MaybeKeepTronAccountAlive, MissingSwapPayloadParamaters, NetworkDown, NetworkError, NoAccessToCamera, NoAddressesFound, NoDBPathGiven, NotEnoughBalance, NotEnoughBalanceBecauseDestinationNotCreated, NotEnoughBalanceFees, NotEnoughBalanceInParentAccount, NotEnoughBalanceSwap, NotEnoughBalanceToDelegate, NotEnoughGas, NotEnoughGasSwap, NotEnoughSpendableBalance, NotEnoughToRestake, NotEnoughToStake, NotEnoughToUnstake, NotSupportedLegacyAddress, OpReturnDataSizeLimit, PairingFailed, PasswordIncorrectError, PasswordsDontMatchError, PeerRemovedPairing, PendingOperation, PinNotSet, PriorityFeeHigherThanMaxFee, PriorityFeeTooHigh, PriorityFeeTooLow, RecipientRequired, RecommendSubAccountsToEmpty, RecommendUndelegation, ReplacementTransactionUnderpriced, RestakeNotEnoughStakedBalanceLeft, SequenceNumberError, SyncError, TimeoutTagged, TransactionHasBeenValidatedError, TransportExchangeTimeoutError, TronEmptyAccount, UnavailableTezosOriginatedAccountReceive, UnavailableTezosOriginatedAccountSend, UnexpectedBootloader, UnknownMCU, UnresponsiveDeviceError, UnstakeNotEnoughStakedBalanceLeft, UpdateFetchFileFail, UpdateIncorrectHash, UpdateIncorrectSig, UpdateYourApp, UserRefusedAddress, UserRefusedAllowManager, UserRefusedDeviceNameChange, UserRefusedFirmwareUpdate, UserRefusedOnDevice, WebsocketConnectionError, WebsocketConnectionFailed, WrongAppForCurrency, WrongDeviceForAccount, WrongDeviceForAccountPayout, WrongDeviceForAccountRefund, addCustomErrorDeserializer, deserializeError, getAltStatusMessage, serializeError

;// ./node_modules/@ledgerhq/errors/lib-es/helpers.js
/* eslint-disable no-continue */
/* eslint-disable no-unused-vars */
/* eslint-disable no-param-reassign */
/* eslint-disable no-prototype-builtins */
const errorClasses = {};
const deserializers = {};
const addCustomErrorDeserializer = (name, deserializer) => {
    deserializers[name] = deserializer;
};
const createCustomErrorClass = (name) => {
    class CustomErrorClass extends Error {
        cause;
        constructor(message, fields, options) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            super(message || name, options);
            // Set the prototype explicitly. See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, CustomErrorClass.prototype);
            this.name = name;
            if (fields) {
                for (const k in fields) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    this[k] = fields[k];
                }
            }
            if (options && isObject(options) && "cause" in options && !this.cause) {
                // .cause was specified but the superconstructor
                // did not create an instance property.
                const cause = options.cause;
                this.cause = cause;
                if ("stack" in cause) {
                    this.stack = this.stack + "\nCAUSE: " + cause.stack;
                }
            }
        }
    }
    errorClasses[name] = CustomErrorClass;
    return CustomErrorClass;
};
function isObject(value) {
    return typeof value === "object";
}
// inspired from https://github.com/programble/errio/blob/master/index.js
const deserializeError = (object) => {
    if (object && typeof object === "object") {
        try {
            if (typeof object.message === "string") {
                const msg = JSON.parse(object.message);
                if (msg.message && msg.name) {
                    object = msg;
                }
            }
        }
        catch (e) {
            // nothing
        }
        let error;
        if (typeof object.name === "string") {
            const { name } = object;
            const des = deserializers[name];
            if (des) {
                error = des(object);
            }
            else {
                let constructor = name === "Error" ? Error : errorClasses[name];
                if (!constructor) {
                    console.warn("deserializing an unknown class '" + name + "'");
                    constructor = createCustomErrorClass(name);
                }
                error = Object.create(constructor.prototype);
                try {
                    for (const prop in object) {
                        if (object.hasOwnProperty(prop)) {
                            error[prop] = object[prop];
                        }
                    }
                }
                catch (e) {
                    // sometimes setting a property can fail (e.g. .name)
                }
            }
        }
        else {
            if (typeof object.message === "string") {
                error = new Error(object.message);
            }
        }
        if (error && !error.stack && Error.captureStackTrace) {
            Error.captureStackTrace(error, deserializeError);
        }
        return error;
    }
    return new Error(String(object));
};
// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js
const serializeError = (value) => {
    if (!value)
        return value;
    if (typeof value === "object") {
        return destroyCircular(value, []);
    }
    if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
};
// https://www.npmjs.com/package/destroy-circular
function destroyCircular(from, seen) {
    const to = {};
    seen.push(from);
    for (const key of Object.keys(from)) {
        const value = from[key];
        if (typeof value === "function") {
            continue;
        }
        if (!value || typeof value !== "object") {
            to[key] = value;
            continue;
        }
        if (seen.indexOf(from[key]) === -1) {
            to[key] = destroyCircular(from[key], seen.slice(0));
            continue;
        }
        to[key] = "[Circular]";
    }
    if (typeof from.name === "string") {
        to.name = from.name;
    }
    if (typeof from.message === "string") {
        to.message = from.message;
    }
    if (typeof from.stack === "string") {
        to.stack = from.stack;
    }
    return to;
}
//# sourceMappingURL=helpers.js.map
;// ./node_modules/@ledgerhq/errors/lib-es/index.js


const AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");
const AccountNotSupported = createCustomErrorClass("AccountNotSupported");
const AccountAwaitingSendPendingOperations = createCustomErrorClass("AccountAwaitingSendPendingOperations");
const AmountRequired = createCustomErrorClass("AmountRequired");
const BluetoothRequired = createCustomErrorClass("BluetoothRequired");
const BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");
const CantOpenDevice = createCustomErrorClass("CantOpenDevice");
const CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");
const ClaimRewardsFeesWarning = createCustomErrorClass("ClaimRewardsFeesWarning");
const CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");
const DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");
const DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");
const DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");
const DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");
const DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");
const DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");
const DeviceHalted = createCustomErrorClass("DeviceHalted");
const DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");
const DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");
const DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");
const DeviceNeedsRestart = createCustomErrorClass("DeviceSocketNoBulkStatus");
const UnresponsiveDeviceError = createCustomErrorClass("UnresponsiveDeviceError");
const DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
const DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
const DeviceExtractOnboardingStateError = createCustomErrorClass("DeviceExtractOnboardingStateError");
const DeviceOnboardingStatePollingError = createCustomErrorClass("DeviceOnboardingStatePollingError");
const EnpointConfigError = createCustomErrorClass("EnpointConfig");
const EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");
const FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");
const FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");
const HardResetFail = createCustomErrorClass("HardResetFail");
const InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");
const InvalidAddress = createCustomErrorClass("InvalidAddress");
const InvalidNonce = createCustomErrorClass("InvalidNonce");
const InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
const LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");
const LatestFirmwareVersionRequired = createCustomErrorClass("LatestFirmwareVersionRequired");
const UnknownMCU = createCustomErrorClass("UnknownMCU");
const LedgerAPIError = createCustomErrorClass("LedgerAPIError");
const LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");
const LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");
const ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");
const ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");
const ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");
const ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");
const ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");
const ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
const ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");
const ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");
const NetworkDown = createCustomErrorClass("NetworkDown");
const NetworkError = createCustomErrorClass("NetworkError");
const NoAddressesFound = createCustomErrorClass("NoAddressesFound");
const NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");
const NotEnoughBalanceFees = createCustomErrorClass("NotEnoughBalanceFees");
const NotEnoughBalanceSwap = createCustomErrorClass("NotEnoughBalanceSwap");
const NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");
const UnstakeNotEnoughStakedBalanceLeft = createCustomErrorClass("UnstakeNotEnoughStakedBalanceLeft");
const RestakeNotEnoughStakedBalanceLeft = createCustomErrorClass("RestakeNotEnoughStakedBalanceLeft");
const NotEnoughToRestake = createCustomErrorClass("NotEnoughToRestake");
const NotEnoughToUnstake = createCustomErrorClass("NotEnoughToUnstake");
const NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");
const NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");
const NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
const NotEnoughToStake = createCustomErrorClass("NotEnoughToStake");
const NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");
const NotEnoughGas = createCustomErrorClass("NotEnoughGas");
// Error message specifically for the PTX swap flow
const NotEnoughGasSwap = createCustomErrorClass("NotEnoughGasSwap");
const TronEmptyAccount = createCustomErrorClass("TronEmptyAccount");
const MaybeKeepTronAccountAlive = createCustomErrorClass("MaybeKeepTronAccountAlive");
const NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");
const GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");
const PriorityFeeTooLow = createCustomErrorClass("PriorityFeeTooLow");
const PriorityFeeTooHigh = createCustomErrorClass("PriorityFeeTooHigh");
const PriorityFeeHigherThanMaxFee = createCustomErrorClass("PriorityFeeHigherThanMaxFee");
const MaxFeeTooLow = createCustomErrorClass("MaxFeeTooLow");
const PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");
const PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");
const RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");
const RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");
const TimeoutTagged = createCustomErrorClass("TimeoutTagged");
const UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");
const MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");
const RecipientRequired = createCustomErrorClass("RecipientRequired");
const UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
const UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
const UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");
const UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");
const UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");
const UpdateYourApp = createCustomErrorClass("UpdateYourApp");
const UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");
const UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");
const UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");
const UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");
const UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice"); // TODO rename because it's just for transaction refusal
const PinNotSet = createCustomErrorClass("PinNotSet");
const ExpertModeRequired = createCustomErrorClass("ExpertModeRequired");
const TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
const TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
const TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
const TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
const TransactionHasBeenValidatedError = createCustomErrorClass("TransactionHasBeenValidatedError");
const TransportExchangeTimeoutError = createCustomErrorClass("TransportExchangeTimeoutError");
const DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");
const WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");
const WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");
const WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");
const WrongDeviceForAccountPayout = createCustomErrorClass("WrongDeviceForAccountPayout");
const MissingSwapPayloadParamaters = createCustomErrorClass("MissingSwapPayloadParamaters");
const WrongDeviceForAccountRefund = createCustomErrorClass("WrongDeviceForAccountRefund");
const WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");
const ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");
const CantScanQRCode = createCustomErrorClass("CantScanQRCode");
const FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");
const FeeNotLoadedSwap = createCustomErrorClass("FeeNotLoadedSwap");
const FeeRequired = createCustomErrorClass("FeeRequired");
const FeeTooHigh = createCustomErrorClass("FeeTooHigh");
const PendingOperation = createCustomErrorClass("PendingOperation");
const SyncError = createCustomErrorClass("SyncError");
const PairingFailed = createCustomErrorClass("PairingFailed");
const PeerRemovedPairing = createCustomErrorClass("PeerRemovedPairing");
const GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");
const LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");
const LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");
const FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");
// SpeedUp / Cancel EVM tx
const ReplacementTransactionUnderpriced = createCustomErrorClass("ReplacementTransactionUnderpriced");
// Bitcoin family
const OpReturnDataSizeLimit = createCustomErrorClass("OpReturnSizeLimit");
const DustLimit = createCustomErrorClass("DustLimit");
// Language
const LanguageNotFound = createCustomErrorClass("LanguageNotFound");
// db stuff, no need to translate
const NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");
const DBWrongPassword = createCustomErrorClass("DBWrongPassword");
const DBNotReset = createCustomErrorClass("DBNotReset");
const SequenceNumberError = createCustomErrorClass("SequenceNumberError");
const DisabledTransactionBroadcastError = createCustomErrorClass("DisabledTransactionBroadcastError");
/**
 * Type of a Transport error used to represent all equivalent errors coming from all possible implementation of Transport
 */
var HwTransportErrorType;
(function (HwTransportErrorType) {
    HwTransportErrorType["Unknown"] = "Unknown";
    HwTransportErrorType["LocationServicesDisabled"] = "LocationServicesDisabled";
    HwTransportErrorType["LocationServicesUnauthorized"] = "LocationServicesUnauthorized";
    HwTransportErrorType["BluetoothScanStartFailed"] = "BluetoothScanStartFailed";
})(HwTransportErrorType || (HwTransportErrorType = {}));
/**
 * Represents an error coming from the usage of any Transport implementation.
 *
 * Needed to map a specific implementation error into an error that
 * can be managed by any code unaware of the specific Transport implementation
 * that was used.
 */
class HwTransportError extends Error {
    type;
    constructor(type, message) {
        super(message);
        this.name = "HwTransportError";
        this.type = type;
        // Needed as long as we target < ES6
        Object.setPrototypeOf(this, HwTransportError.prototype);
    }
}
/**
 * TransportError is used for any generic transport errors.
 * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
 */
class TransportError extends Error {
    id;
    constructor(message, id) {
        const name = "TransportError";
        super(message || name);
        this.name = name;
        this.message = message;
        this.stack = new Error(message).stack;
        this.id = id;
    }
}
addCustomErrorDeserializer("TransportError", e => new TransportError(e.message, e.id));
const StatusCodes = {
    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,
    ALGORITHM_NOT_SUPPORTED: 0x9484,
    CLA_NOT_SUPPORTED: 0x6e00,
    CODE_BLOCKED: 0x9840,
    CODE_NOT_INITIALIZED: 0x9802,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,
    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,
    CONTRADICTION_INVALIDATION: 0x9810,
    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,
    DEVICE_IN_RECOVERY_MODE: 0x662f,
    CUSTOM_IMAGE_EMPTY: 0x662e,
    FILE_ALREADY_EXISTS: 0x6a89,
    FILE_NOT_FOUND: 0x9404,
    GP_AUTH_FAILED: 0x6300,
    HALTED: 0x6faa,
    INCONSISTENT_FILE: 0x9408,
    INCORRECT_DATA: 0x6a80,
    INCORRECT_LENGTH: 0x6700,
    INCORRECT_P1_P2: 0x6b00,
    INS_NOT_SUPPORTED: 0x6d00,
    DEVICE_NOT_ONBOARDED: 0x6d07,
    DEVICE_NOT_ONBOARDED_2: 0x6611,
    INVALID_KCV: 0x9485,
    INVALID_OFFSET: 0x9402,
    LICENSING: 0x6f42,
    LOCKED_DEVICE: 0x5515,
    MAX_VALUE_REACHED: 0x9850,
    MEMORY_PROBLEM: 0x9240,
    MISSING_CRITICAL_PARAMETER: 0x6800,
    NO_EF_SELECTED: 0x9400,
    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,
    OK: 0x9000,
    PIN_REMAINING_ATTEMPTS: 0x63c0,
    REFERENCED_DATA_NOT_FOUND: 0x6a88,
    SECURITY_STATUS_NOT_SATISFIED: 0x6982,
    TECHNICAL_PROBLEM: 0x6f00,
    UNKNOWN_APDU: 0x6d02,
    USER_REFUSED_ON_DEVICE: 0x5501,
    NOT_ENOUGH_SPACE: 0x5102,
    APP_NOT_FOUND_OR_INVALID_CONTEXT: 0x5123,
    INVALID_APP_NAME_LENGTH: 0x670a,
    GEN_AES_KEY_FAILED: 0x5419,
    INTERNAL_CRYPTO_OPERATION_FAILED: 0x541a,
    INTERNAL_COMPUTE_AES_CMAC_FAILED: 0x541b,
    ENCRYPT_APP_STORAGE_FAILED: 0x541c,
    INVALID_BACKUP_STATE: 0x6642,
    PIN_NOT_SET: 0x5502,
    INVALID_BACKUP_LENGTH: 0x6733,
    INVALID_RESTORE_STATE: 0x6643,
    INVALID_CHUNK_LENGTH: 0x6734,
    INVALID_BACKUP_HEADER: 0x684a,
    // Not documented:
    TRUSTCHAIN_WRONG_SEED: 0xb007,
};
function getAltStatusMessage(code) {
    switch (code) {
        // improve text of most common errors
        case 0x6700:
            return "Incorrect length";
        case 0x6800:
            return "Missing critical parameter";
        case 0x6982:
            return "Security not satisfied (dongle locked or have invalid access rights)";
        case 0x6985:
            return "Condition of use not satisfied (denied by the user?)";
        case 0x6a80:
            return "Invalid data received";
        case 0x6b00:
            return "Invalid parameter received";
        case 0x5515:
            return "Locked device";
    }
    if (0x6f00 <= code && code <= 0x6fff) {
        return "Internal error, please report";
    }
}
/**
 * Error thrown when a device returned a non success status.
 * the error.statusCode is one of the `StatusCodes` exported by this library.
 */
class TransportStatusError extends Error {
    statusCode;
    statusText;
    /**
     * @param statusCode The error status code coming from a Transport implementation
     * @param options containing:
     *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
     *  . Ex: LockedDeviceError. Default to true.
     */
    constructor(statusCode, { canBeMappedToChildError = true } = {}) {
        const statusText = Object.keys(StatusCodes).find(k => StatusCodes[k] === statusCode) || "UNKNOWN_ERROR";
        const smsg = getAltStatusMessage(statusCode) || statusText;
        const statusCodeStr = statusCode.toString(16);
        const message = `Ledger device: ${smsg} (0x${statusCodeStr})`;
        super(message);
        this.name = "TransportStatusError";
        this.statusCode = statusCode;
        this.statusText = statusText;
        Object.setPrototypeOf(this, TransportStatusError.prototype);
        // Maps to a LockedDeviceError
        if (canBeMappedToChildError && statusCode === StatusCodes.LOCKED_DEVICE) {
            return new LockedDeviceError(message);
        }
    }
}
class LockedDeviceError extends TransportStatusError {
    constructor(message) {
        super(StatusCodes.LOCKED_DEVICE, { canBeMappedToChildError: false });
        if (message) {
            this.message = message;
        }
        this.name = "LockedDeviceError";
        Object.setPrototypeOf(this, LockedDeviceError.prototype);
    }
}
class DeviceMangementKitError extends Error {
    constructor(name, message) {
        super(message);
        this.name = name;
        Object.setPrototypeOf(this, DeviceMangementKitError.prototype);
    }
}
addCustomErrorDeserializer("TransportStatusError", e => new TransportStatusError(e.statusCode));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ TransportWebUSB; }
});

// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__("./node_modules/events/events.js");
var events_default = /*#__PURE__*/__webpack_require__.n(events);
// EXTERNAL MODULE: ./node_modules/@ledgerhq/errors/lib-es/index.js + 1 modules
var lib_es = __webpack_require__("./node_modules/@ledgerhq/errors/lib-es/index.js");
// EXTERNAL MODULE: ./node_modules/@ledgerhq/logs/lib-es/index.js
var logs_lib_es = __webpack_require__("./node_modules/@ledgerhq/logs/lib-es/index.js");
;// ./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];




const DEFAULT_LOG_TYPE = "transport";
/**
 * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.
 * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).
 * It is an abstract class that needs to be implemented.
 */
class Transport {
    exchangeTimeout = 30000;
    unresponsiveTimeout = 15000;
    deviceModel = null;
    tracer;
    constructor({ context, logType } = {}) {
        this.tracer = new logs_lib_es/* LocalTracer */.PR(logType ?? DEFAULT_LOG_TYPE, context);
    }
    /**
     * Check if the transport is supported on the current platform/browser.
     * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.
     */
    static isSupported;
    /**
     * List all available descriptors for the transport.
     * For a better granularity, checkout `listen()`.
     *
     * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.
     * @example
     * TransportFoo.list().then(descriptors => ...)
     */
    static list;
    /**
     * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.
     * A DescriptorEvent is an object containing a "descriptor" and a "type" field. The "type" field can be "add" or "remove", and the "descriptor" field can be passed to the "open" method.
     * The "listen" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.
     * @param {Observer<DescriptorEvent<any>>} observer - An object with "next", "error", and "complete" functions, following the observer pattern.
     * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop listening to descriptors.
     * @example
    const sub = TransportFoo.listen({
    next: e => {
      if (e.type==="add") {
        sub.unsubscribe();
        const transport = await TransportFoo.open(e.descriptor);
        ...
      }
    },
    error: error => {},
    complete: () => {}
    })
     */
    static listen;
    /**
     * Attempt to create a Transport instance with a specific descriptor.
     * @param {any} descriptor - The descriptor to open the transport with.
     * @param {number} timeout - An optional timeout for the transport connection.
     * @param {TraceContext} context Optional tracing/log context
     * @returns {Promise<Transport>} A promise that resolves with a Transport instance.
     * @example
    TransportFoo.open(descriptor).then(transport => ...)
     */
    static open;
    /**
     * Send data to the device using a low level API.
     * It's recommended to use the "send" method for a higher level API.
     * @param {Buffer} apdu - The data to send.
     * @param {Object} options - Contains optional options for the exchange function
     *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
     */
    exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {
        throw new Error("exchange not implemented");
    }
    /**
     * Send apdus in batch to the device using a low level API.
     * The default implementation is to call exchange for each apdu.
     * @param {Array<Buffer>} apdus - array of apdus to send.
     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
     * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
     */
    exchangeBulk(apdus, observer) {
        let unsubscribed = false;
        const unsubscribe = () => {
            unsubscribed = true;
        };
        const main = async () => {
            if (unsubscribed)
                return;
            for (const apdu of apdus) {
                const r = await this.exchange(apdu);
                if (unsubscribed)
                    return;
                const status = r.readUInt16BE(r.length - 2);
                if (status !== lib_es/* StatusCodes */.vi.OK) {
                    throw new lib_es/* TransportStatusError */._3(status);
                }
                observer.next(r);
            }
        };
        main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));
        return { unsubscribe };
    }
    /**
     * Set the "scramble key" for the next data exchanges with the device.
     * Each app can have a different scramble key and it is set internally during instantiation.
     * @param {string} key - The scramble key to set.
     * deprecated This method is no longer needed for modern transports and should be migrated away from.
     * no @ before deprecated as it breaks documentationjs on version 14.0.2
     * https://github.com/documentationjs/documentation/issues/1596
     */
    setScrambleKey(_key) { }
    /**
     * Close the connection with the device.
     *
     * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
     * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
     * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
     *
     * @returns {Promise<void>} A promise that resolves when the transport is closed.
     */
    close() {
        return Promise.resolve();
    }
    _events = new (events_default())();
    /**
     * Listen for an event on the transport instance.
     * Transport implementations may have specific events. Common events include:
     * "disconnect" : triggered when the transport is disconnected.
     * @param {string} eventName - The name of the event to listen for.
     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
     */
    on(eventName, cb) {
        this._events.on(eventName, cb);
    }
    /**
     * Stop listening to an event on an instance of transport.
     */
    off(eventName, cb) {
        this._events.removeListener(eventName, cb);
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
    }
    /**
     * Enable or not logs of the binary exchange
     */
    setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    }
    /**
     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
     */
    setExchangeTimeout(exchangeTimeout) {
        this.exchangeTimeout = exchangeTimeout;
    }
    /**
     * Define the delay before emitting "unresponsive" on an exchange that does not respond
     */
    setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
        this.unresponsiveTimeout = unresponsiveTimeout;
    }
    /**
     * Send data to the device using the higher level API.
     *
     * @param {number} cla - The instruction class for the command.
     * @param {number} ins - The instruction code for the command.
     * @param {number} p1 - The first parameter for the instruction.
     * @param {number} p2 - The second parameter for the instruction.
     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.
     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].
     * @param {Object} options - Contains optional options for the exchange function
     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists
     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
     */
    send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [lib_es/* StatusCodes */.vi.OK], { abortTimeoutMs } = {}) => {
        const tracer = this.tracer.withUpdatedContext({ function: "send" });
        if (data.length >= 256) {
            tracer.trace("data.length exceeded 256 bytes limit", { dataLength: data.length });
            throw new lib_es/* TransportError */.wX("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
        }
        tracer.trace("Starting an exchange", { abortTimeoutMs });
        const response = await this.exchange(
        // The size of the data is added in 1 byte just before `data`
        Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), { abortTimeoutMs });
        tracer.trace("Received response from exchange");
        const sw = response.readUInt16BE(response.length - 2);
        if (!statusList.some(s => s === sw)) {
            throw new lib_es/* TransportStatusError */._3(sw);
        }
        return response;
    };
    /**
     * create() allows to open the first descriptor available or
     * throw if there is none or if timeout is reached.
     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
     * @example
    TransportFoo.create().then(transport => ...)
     */
    static create(openTimeout = 3000, listenTimeout) {
        return new Promise((resolve, reject) => {
            let found = false;
            const sub = this.listen({
                next: e => {
                    found = true;
                    if (sub)
                        sub.unsubscribe();
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    this.open(e.descriptor, openTimeout).then(resolve, reject);
                },
                error: e => {
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    reject(e);
                },
                complete: () => {
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    if (!found) {
                        reject(new lib_es/* TransportError */.wX(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                    }
                },
            });
            const listenTimeoutId = listenTimeout
                ? setTimeout(() => {
                    sub.unsubscribe();
                    reject(new lib_es/* TransportError */.wX(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
                }, listenTimeout)
                : null;
        });
    }
    // Blocks other exchange to happen concurrently
    exchangeBusyPromise;
    /**
     * Wrapper to make an exchange "atomic" (blocking any other exchange)
     *
     * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
     *
     * @param f The exchange job, using the transport to run
     * @returns a Promise resolving with the output of the given job
     */
    async exchangeAtomicImpl(f) {
        const tracer = this.tracer.withUpdatedContext({
            function: "exchangeAtomicImpl",
            unresponsiveTimeout: this.unresponsiveTimeout,
        });
        if (this.exchangeBusyPromise) {
            tracer.trace("Atomic exchange is already busy");
            throw new lib_es/* TransportRaceCondition */.ug("An action was already pending on the Ledger device. Please deny or reconnect.");
        }
        // Sets the atomic guard
        let resolveBusy;
        const busyPromise = new Promise(r => {
            resolveBusy = r;
        });
        this.exchangeBusyPromise = busyPromise;
        // The device unresponsiveness handler
        let unresponsiveReached = false;
        const timeout = setTimeout(() => {
            tracer.trace(`Timeout reached, emitting Transport event "unresponsive"`, {
                unresponsiveTimeout: this.unresponsiveTimeout,
            });
            unresponsiveReached = true;
            this.emit("unresponsive");
        }, this.unresponsiveTimeout);
        try {
            const res = await f();
            if (unresponsiveReached) {
                tracer.trace("Device was unresponsive, emitting responsive");
                this.emit("responsive");
            }
            return res;
        }
        finally {
            tracer.trace("Finalize, clearing busy guard");
            clearTimeout(timeout);
            if (resolveBusy)
                resolveBusy();
            this.exchangeBusyPromise = null;
        }
    }
    decorateAppAPIMethods(self, methods, scrambleKey) {
        for (const methodName of methods) {
            self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
        }
    }
    _appAPIlock = null;
    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
        return async (...args) => {
            const { _appAPIlock } = this;
            if (_appAPIlock) {
                return Promise.reject(new lib_es/* TransportError */.wX("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
            }
            try {
                this._appAPIlock = methodName;
                this.setScrambleKey(scrambleKey);
                return await f.apply(ctx, args);
            }
            finally {
                this._appAPIlock = null;
            }
        };
    }
    /**
     * Sets the context used by the logging/tracing mechanism
     *
     * Useful when re-using (cached) the same Transport instance,
     * but with a new tracing context.
     *
     * @param context A TraceContext, that can undefined to reset the context
     */
    setTraceContext(context) {
        this.tracer = this.tracer.withContext(context);
    }
    /**
     * Updates the context used by the logging/tracing mechanism
     *
     * The update only overrides the key-value that are already defined in the current context.
     *
     * @param contextToAdd A TraceContext that will be added to the current context
     */
    updateTraceContext(contextToAdd) {
        this.tracer.updateContext(contextToAdd);
    }
    /**
     * Gets the tracing context of the transport instance
     */
    getTraceContext() {
        return this.tracer.getContext();
    }
    static ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
    static ErrorMessage_NoDeviceFound = "No Ledger device found";
}
//# sourceMappingURL=Transport.js.map
;// ./node_modules/@ledgerhq/devices/lib-es/hid-framing.js
/* provided dependency */ var hid_framing_Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];

const Tag = 0x05;
function asUInt16BE(value) {
    const b = hid_framing_Buffer.alloc(2);
    b.writeUInt16BE(value, 0);
    return b;
}
const initialAcc = {
    data: hid_framing_Buffer.alloc(0),
    dataLength: 0,
    sequence: 0,
};
/**
 * Object to handle HID frames (encoding and decoding)
 *
 * @param channel
 * @param packetSize The HID protocol packet size in bytes (usually 64)
 */
const createHIDframing = (channel, packetSize) => {
    return {
        /**
         * Frames/encodes an APDU message into HID USB packets/frames
         *
         * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
         * @returns an array of HID USB frames ready to be sent
         */
        makeBlocks(apdu) {
            // Encodes the APDU length in 2 bytes before the APDU itself.
            // The length is measured as the number of bytes.
            // As the size of the APDU `data` should have been added in 1 byte just before `data`,
            // the minimum size of an APDU is 5 bytes.
            let data = hid_framing_Buffer.concat([asUInt16BE(apdu.length), apdu]);
            const blockSize = packetSize - 5;
            const nbBlocks = Math.ceil(data.length / blockSize);
            // Fills data with 0-padding
            data = hid_framing_Buffer.concat([data, hid_framing_Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);
            const blocks = [];
            for (let i = 0; i < nbBlocks; i++) {
                const head = hid_framing_Buffer.alloc(5);
                head.writeUInt16BE(channel, 0);
                head.writeUInt8(Tag, 2);
                head.writeUInt16BE(i, 3);
                // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array
                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
                blocks.push(hid_framing_Buffer.concat([head, chunk]));
            }
            return blocks;
        },
        /**
         * Reduces HID USB packets/frames to one response.
         *
         * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
         *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
         * @param chunk Current chunk to reduce into accumulator
         * @returns An accumulator value updated with the current chunk
         */
        reduceResponse(acc, chunk) {
            let { data, dataLength, sequence } = acc || initialAcc;
            if (chunk.readUInt16BE(0) !== channel) {
                throw new lib_es/* TransportError */.wX("Invalid channel", "InvalidChannel");
            }
            if (chunk.readUInt8(2) !== Tag) {
                throw new lib_es/* TransportError */.wX("Invalid tag", "InvalidTag");
            }
            if (chunk.readUInt16BE(3) !== sequence) {
                throw new lib_es/* TransportError */.wX("Invalid sequence", "InvalidSequence");
            }
            // Gets the total length of the response from the 1st frame
            if (!acc) {
                dataLength = chunk.readUInt16BE(5);
            }
            sequence++;
            // The total length on the 1st frame takes 2 more bytes
            const chunkData = chunk.slice(acc ? 5 : 7);
            data = hid_framing_Buffer.concat([data, chunkData]);
            // Removes any 0 padding
            if (data.length > dataLength) {
                data = data.slice(0, dataLength);
            }
            return {
                data,
                dataLength,
                sequence,
            };
        },
        /**
         * Returns the response message that has been reduced from the HID USB frames
         *
         * @param acc The accumulator
         * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
         *   accumulator is incorrect (message length is not valid)
         */
        getReducedResult(acc) {
            if (acc && acc.dataLength === acc.data.length) {
                return acc.data;
            }
        },
    };
};
/* harmony default export */ var hid_framing = (createHIDframing);
//# sourceMappingURL=hid-framing.js.map
// EXTERNAL MODULE: ./node_modules/semver/index.js
var semver = __webpack_require__("./node_modules/semver/index.js");
var semver_default = /*#__PURE__*/__webpack_require__.n(semver);
;// ./node_modules/@ledgerhq/devices/lib-es/index.js

/**
 * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)
 *
 ** Model
 * Ledger Nano S : 0x10
 * Ledger Blue : 0x00
 * Ledger Nano X : 0x40
 *
 ** Interface support bitfield
 * Generic HID : 0x01
 * Keyboard HID : 0x02
 * U2F : 0x04
 * CCID : 0x08
 * WebUSB : 0x10
 */
const IIGenericHID = 0x01;
const IIKeyboardHID = 0x02;
const IIU2F = 0x04;
const IICCID = 0x08;
const IIWebUSB = 0x10;
var DeviceModelId;
(function (DeviceModelId) {
    /** Ledger Blue */
    DeviceModelId["blue"] = "blue";
    /** Ledger Nano S */
    DeviceModelId["nanoS"] = "nanoS";
    /** Ledger Nano S Plus */
    DeviceModelId["nanoSP"] = "nanoSP";
    /** Ledger Nano X */
    DeviceModelId["nanoX"] = "nanoX";
    /** Ledger Stax */
    DeviceModelId["stax"] = "stax";
    /** Ledger Flex ("europa" is the internal name) */
    DeviceModelId["europa"] = "europa";
    /** Apex */
    DeviceModelId["apex"] = "apex";
})(DeviceModelId || (DeviceModelId = {}));
const devices = {
    [DeviceModelId.blue]: {
        id: DeviceModelId.blue,
        productName: "Ledger Blue",
        productIdMM: 0x00,
        legacyUsbProductId: 0x0000,
        usbOnly: true,
        memorySize: 480 * 1024,
        masks: [0x31000000, 0x31010000],
        getBlockSize: (_firwareVersion) => 4 * 1024,
    },
    [DeviceModelId.nanoS]: {
        id: DeviceModelId.nanoS,
        productName: "Ledger Nano S",
        productIdMM: 0x10,
        legacyUsbProductId: 0x0001,
        usbOnly: true,
        memorySize: 320 * 1024,
        masks: [0x31100000],
        getBlockSize: (firmwareVersion) => semver_default().lt(semver_default().coerce(firmwareVersion) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024,
    },
    [DeviceModelId.nanoX]: {
        id: DeviceModelId.nanoX,
        productName: "Ledger Nano X",
        productIdMM: 0x40,
        legacyUsbProductId: 0x0004,
        usbOnly: false,
        memorySize: 2 * 1024 * 1024,
        masks: [0x33000000],
        getBlockSize: (_firwareVersion) => 4 * 1024,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572",
            },
        ],
    },
    [DeviceModelId.nanoSP]: {
        id: DeviceModelId.nanoSP,
        productName: "Ledger Nano S Plus",
        productIdMM: 0x50,
        legacyUsbProductId: 0x0005,
        usbOnly: true,
        memorySize: 1533 * 1024,
        masks: [0x33100000],
        getBlockSize: (_firmwareVersion) => 32,
    },
    [DeviceModelId.apex]: {
        id: DeviceModelId.apex,
        productName: "Ledger Apex",
        productIdMM: 0x80,
        legacyUsbProductId: 0x0008,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [0x33400000],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
            /**
             * 13D63400-2C97-6004-0001-4C6564676572, 13D63400-2C97-6004-0002-4C6564676572, and 13D63400-2C97-6004-0003-4C6564676572 Characteristics for Service 13D63400-2C97-6004-0000-4C6564676572
             */
            {
                serviceUuid: "13d63400-2c97-6004-0000-4c6564676572", // WILL CHANGE, for now same as Stax
                notifyUuid: "13d63400-2c97-6004-0001-4c6564676572", // WILL CHANGE, for now same as Stax
                writeUuid: "13d63400-2c97-6004-0002-4c6564676572", // WILL CHANGE, for now same as Stax
                writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572", // WILL CHANGE, for now same as Stax
            },
        ],
    },
    [DeviceModelId.stax]: {
        id: DeviceModelId.stax,
        productName: "Ledger Stax",
        productIdMM: 0x60,
        legacyUsbProductId: 0x0006,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [0x33200000],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572",
            },
        ],
    },
    [DeviceModelId.europa]: {
        id: DeviceModelId.europa,
        productName: "Ledger Flex",
        productIdMM: 0x70,
        legacyUsbProductId: 0x0007,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [0x33300000],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572",
            },
        ],
    },
};
const productMap = {
    Blue: DeviceModelId.blue,
    "Nano S": DeviceModelId.nanoS,
    "Nano S Plus": DeviceModelId.nanoSP,
    "Nano X": DeviceModelId.nanoX,
    Stax: DeviceModelId.stax,
    Europa: DeviceModelId.europa,
};
const devicesList = Object.values(devices);
/**
 *
 */
const ledgerUSBVendorId = 0x2c97;
/**
 *
 */
const getDeviceModel = (id) => {
    const info = devices[id];
    if (!info)
        throw new Error("device '" + id + "' does not exist");
    return info;
};
/**
 * Given a `targetId`, return the deviceModel associated to it,
 * based on the first two bytes.
 */
const identifyTargetId = (targetId) => {
    const deviceModel = devicesList.find(({ masks }) => masks.find(mask => (targetId & 0xffff0000) === mask));
    return deviceModel;
};
/**
 * From a given USB product id, return the deviceModel associated to it.
 *
 * The mapping from the product id is only based on the 2 most significant bytes.
 * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.
 */
const identifyUSBProductId = (usbProductId) => {
    const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);
    if (legacy)
        return legacy;
    const mm = usbProductId >> 8;
    const deviceModel = devicesList.find(d => d.productIdMM === mm);
    return deviceModel;
};
const identifyProductName = (productName) => {
    const deviceModel = devicesList.find(d => d.id === productMap[productName]);
    return deviceModel;
};
const bluetoothServices = [];
const serviceUuidToInfos = {};
for (const id in devices) {
    const deviceModel = devices[id];
    const { bluetoothSpec } = deviceModel;
    if (bluetoothSpec) {
        for (let i = 0; i < bluetoothSpec.length; i++) {
            const spec = bluetoothSpec[i];
            bluetoothServices.push(spec.serviceUuid);
            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = {
                deviceModel,
                ...spec,
            };
        }
    }
}
/**
 *
 */
const getBluetoothServiceUuids = () => bluetoothServices;
/**
 *
 */
const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];
//# sourceMappingURL=index.js.map
;// ./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js

const ledgerDevices = [
    {
        vendorId: ledgerUSBVendorId,
    },
];
async function requestLedgerDevice() {
    const device = await navigator.usb.requestDevice({
        filters: ledgerDevices,
    });
    return device;
}
async function getLedgerDevices() {
    const devices = await navigator.usb.getDevices();
    return devices.filter(d => d.vendorId === ledgerUSBVendorId);
}
async function getFirstLedgerDevice() {
    const existingDevices = await getLedgerDevices();
    if (existingDevices.length > 0)
        return existingDevices[0];
    return requestLedgerDevice();
}
const isSupported = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");
//# sourceMappingURL=webusb.js.map
;// ./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js
/* provided dependency */ var TransportWebUSB_Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];






const configurationValue = 1;
const endpointNumber = 3;
/**
 * WebUSB Transport implementation
 * @example
 * import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
 * ...
 * TransportWebUSB.create().then(transport => ...)
 */
class TransportWebUSB extends Transport {
    device;
    deviceModel;
    channel = Math.floor(Math.random() * 0xffff);
    packetSize = 64;
    interfaceNumber;
    constructor(device, interfaceNumber) {
        super();
        this.device = device;
        this.interfaceNumber = interfaceNumber;
        this.deviceModel = identifyUSBProductId(device.productId);
    }
    /**
     * Check if WebUSB transport is supported.
     */
    static isSupported = isSupported;
    /**
     * List the WebUSB devices that was previously authorized by the user.
     */
    static list = getLedgerDevices;
    /**
     * Actively listen to WebUSB devices and emit ONE device
     * that was either accepted before, if not it will trigger the native permission UI.
     *
     * Important: it must be called in the context of a UI click!
     */
    static listen = (observer) => {
        let unsubscribed = false;
        getFirstLedgerDevice().then(device => {
            if (!unsubscribed) {
                const deviceModel = identifyUSBProductId(device.productId);
                observer.next({
                    type: "add",
                    descriptor: device,
                    deviceModel,
                });
                observer.complete();
            }
        }, error => {
            if (window.DOMException && error instanceof window.DOMException && error.code === 18) {
                observer.error(new lib_es/* TransportWebUSBGestureRequired */.e0(error.message));
            }
            else {
                observer.error(new lib_es/* TransportOpenUserCancelled */.kt(error.message));
            }
        });
        function unsubscribe() {
            unsubscribed = true;
        }
        return {
            unsubscribe,
        };
    };
    /**
     * Similar to create() except it will always display the device permission (even if some devices are already accepted).
     */
    static async request() {
        const device = await requestLedgerDevice();
        return TransportWebUSB.open(device);
    }
    /**
     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
     */
    static async openConnected() {
        const devices = await getLedgerDevices();
        if (devices.length === 0)
            return null;
        return TransportWebUSB.open(devices[0]);
    }
    /**
     * Create a Ledger transport with a USBDevice
     */
    static async open(device) {
        await device.open();
        if (device.configuration === null) {
            await device.selectConfiguration(configurationValue);
        }
        await gracefullyResetDevice(device);
        const iface = device.configurations[0].interfaces.find(({ alternates }) => alternates.some(a => a.interfaceClass === 255));
        if (!iface) {
            throw new lib_es/* TransportInterfaceNotAvailable */.pi("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
        }
        const interfaceNumber = iface.interfaceNumber;
        try {
            await device.claimInterface(interfaceNumber);
        }
        catch (e) {
            await device.close();
            throw new lib_es/* TransportInterfaceNotAvailable */.pi(e.message);
        }
        const transport = new TransportWebUSB(device, interfaceNumber);
        const onDisconnect = e => {
            if (device === e.device) {
                // $FlowFixMe
                navigator.usb.removeEventListener("disconnect", onDisconnect);
                transport._emitDisconnect(new lib_es/* DisconnectedDevice */.Ej());
            }
        };
        // $FlowFixMe
        navigator.usb.addEventListener("disconnect", onDisconnect);
        return transport;
    }
    _disconnectEmitted = false;
    _emitDisconnect = (e) => {
        if (this._disconnectEmitted)
            return;
        this._disconnectEmitted = true;
        this.emit("disconnect", e);
    };
    /**
     * Release the transport device
     */
    async close() {
        await this.exchangeBusyPromise;
        await this.device.releaseInterface(this.interfaceNumber);
        await gracefullyResetDevice(this.device);
        await this.device.close();
    }
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */
    async exchange(apdu) {
        const b = await this.exchangeAtomicImpl(async () => {
            const { channel, packetSize } = this;
            (0,logs_lib_es/* log */.Rm)("apdu", "=> " + apdu.toString("hex"));
            const framing = hid_framing(channel, packetSize);
            // Write...
            const blocks = framing.makeBlocks(apdu);
            for (let i = 0; i < blocks.length; i++) {
                await this.device.transferOut(endpointNumber, blocks[i]);
            }
            // Read...
            let result;
            let acc;
            while (!(result = framing.getReducedResult(acc))) {
                const r = await this.device.transferIn(endpointNumber, packetSize);
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                const buffer = TransportWebUSB_Buffer.from(r.data.buffer);
                acc = framing.reduceResponse(acc, buffer);
            }
            (0,logs_lib_es/* log */.Rm)("apdu", "<= " + result.toString("hex"));
            return result;
        }).catch(e => {
            if (e && e.message && e.message.includes("disconnected")) {
                this._emitDisconnect(e);
                throw new lib_es/* DisconnectedDeviceDuringOperation */.iX(e.message);
            }
            throw e;
        });
        return b;
    }
    setScrambleKey() { }
}
async function gracefullyResetDevice(device) {
    try {
        await device.reset();
    }
    catch (err) {
        console.warn(err);
    }
}
//# sourceMappingURL=TransportWebUSB.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/logs/lib-es/index.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PR: function() { return /* binding */ LocalTracer; },
/* harmony export */   Rm: function() { return /* binding */ log; }
/* harmony export */ });
/* unused harmony exports trace, listen */
let id = 0;
const subscribers = [];
/**
 * Logs something
 *
 * @param type a namespaced identifier of the log (it is not a level like "debug", "error" but more like "apdu-in", "apdu-out", etc...)
 * @param message a clear message of the log associated to the type
 */
const log = (type, message, data) => {
    const obj = {
        type,
        id: String(++id),
        date: new Date(),
    };
    if (message)
        obj.message = message;
    if (data)
        obj.data = data;
    dispatch(obj);
};
/**
 * A simple tracer function, only expanding the existing log function
 *
 * Its goal is to capture more context than a log function.
 * This is simple for now, but can be improved later.
 *
 * @param context Anything representing the context where the log occurred
 */
const trace = ({ type, message, data, context, }) => {
    const obj = {
        type,
        id: String(++id),
        date: new Date(),
    };
    if (message)
        obj.message = message;
    if (data)
        obj.data = data;
    if (context)
        obj.context = context;
    dispatch(obj);
};
/**
 * A simple tracer class, that can be used to avoid repetition when using the `trace` function
 *
 * Its goal is to capture more context than a log function.
 * This is simple for now, but can be improved later.
 *
 * @param type A given type (not level) for the current local tracer ("hw", "withDevice", etc.)
 * @param context Anything representing the context where the log occurred
 */
class LocalTracer {
    type;
    context;
    constructor(type, context) {
        this.type = type;
        this.context = context;
    }
    trace(message, data) {
        trace({
            type: this.type,
            message,
            data,
            context: this.context,
        });
    }
    getContext() {
        return this.context;
    }
    setContext(context) {
        this.context = context;
    }
    updateContext(contextToAdd) {
        this.context = { ...this.context, ...contextToAdd };
    }
    getType() {
        return this.type;
    }
    setType(type) {
        this.type = type;
    }
    /**
     * Create a new instance of the LocalTracer with an updated `type`
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     */
    withType(type) {
        return new LocalTracer(type, this.context);
    }
    /**
     * Create a new instance of the LocalTracer with a new `context`
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     *
     * @param context A TraceContext, that can undefined to reset the context
     */
    withContext(context) {
        return new LocalTracer(this.type, context);
    }
    /**
     * Create a new instance of the LocalTracer with an updated `context`,
     * on which an additional context is merged with the existing one.
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     */
    withUpdatedContext(contextToAdd) {
        return new LocalTracer(this.type, { ...this.context, ...contextToAdd });
    }
}
/**
 * Adds a subscribers to the emitted logs.
 *
 * @param cb that is called for each future log() with the Log object
 * @return a function that can be called to unsubscribe the listener
 */
const listen = (cb) => {
    subscribers.push(cb);
    return () => {
        const i = subscribers.indexOf(cb);
        if (i !== -1) {
            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952
            subscribers[i] = subscribers[subscribers.length - 1];
            subscribers.pop();
        }
    };
};
function dispatch(log) {
    for (let i = 0; i < subscribers.length; i++) {
        try {
            subscribers[i](log);
        }
        catch (e) {
            console.error(e);
        }
    }
}
if (typeof window !== "undefined") {
    window.__ledgerLogsListen = listen;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__("./node_modules/semver/internal/parse-options.js")
const { safeRe: re, t } = __webpack_require__("./node_modules/semver/internal/re.js")
const cmp = __webpack_require__("./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__("./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const Range = __webpack_require__("./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SPACE_CHARACTERS = /\s+/g

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.formatted = undefined
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.formatted = undefined
  }

  get range () {
    if (this.formatted === undefined) {
      this.formatted = ''
      for (let i = 0; i < this.set.length; i++) {
        if (i > 0) {
          this.formatted += '||'
        }
        const comps = this.set[i]
        for (let k = 0; k < comps.length; k++) {
          if (k > 0) {
            this.formatted += ' '
          }
          this.formatted += comps[k].toString().trim()
        }
      }
    }
    return this.formatted
  }

  format () {
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = __webpack_require__("./node_modules/semver/internal/lrucache.js")
const cache = new LRU()

const parseOptions = __webpack_require__("./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__("./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__("./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__("./node_modules/semver/internal/re.js")
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__("./node_modules/semver/internal/constants.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const debug = __webpack_require__("./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__("./node_modules/semver/internal/constants.js")
const { safeRe: re, t } = __webpack_require__("./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__("./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__("./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
        version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('build compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    if (release.startsWith('pre')) {
      if (!identifier && identifierBase === false) {
        throw new Error('invalid increment argument: identifier is empty')
      }
      // Avoid an invalid semver results
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE])
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`)
        }
      }
    }

    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break
      case 'release':
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`)
        }
        this.prerelease.length = 0
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const parse = __webpack_require__("./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const eq = __webpack_require__("./node_modules/semver/functions/eq.js")
const neq = __webpack_require__("./node_modules/semver/functions/neq.js")
const gt = __webpack_require__("./node_modules/semver/functions/gt.js")
const gte = __webpack_require__("./node_modules/semver/functions/gte.js")
const lt = __webpack_require__("./node_modules/semver/functions/lt.js")
const lte = __webpack_require__("./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const parse = __webpack_require__("./node_modules/semver/functions/parse.js")
const { safeRe: re, t } = __webpack_require__("./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]
    let next
    while ((next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1
  }

  if (match === null) {
    return null
  }

  const major = match[2]
  const minor = match[3] || '0'
  const patch = match[4] || '0'
  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''

  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const parse = __webpack_require__("./node_modules/semver/functions/parse.js")

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length
  const lowHasPre = !!lowVersion.prerelease.length

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // If the main part has no difference
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return 'minor'
      }
      return 'patch'
    }
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
}

module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const parse = __webpack_require__("./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compareBuild = __webpack_require__("./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const compareBuild = __webpack_require__("./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const parse = __webpack_require__("./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__("./node_modules/semver/internal/re.js")
const constants = __webpack_require__("./node_modules/semver/internal/constants.js")
const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const identifiers = __webpack_require__("./node_modules/semver/internal/identifiers.js")
const parse = __webpack_require__("./node_modules/semver/functions/parse.js")
const valid = __webpack_require__("./node_modules/semver/functions/valid.js")
const clean = __webpack_require__("./node_modules/semver/functions/clean.js")
const inc = __webpack_require__("./node_modules/semver/functions/inc.js")
const diff = __webpack_require__("./node_modules/semver/functions/diff.js")
const major = __webpack_require__("./node_modules/semver/functions/major.js")
const minor = __webpack_require__("./node_modules/semver/functions/minor.js")
const patch = __webpack_require__("./node_modules/semver/functions/patch.js")
const prerelease = __webpack_require__("./node_modules/semver/functions/prerelease.js")
const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
const rcompare = __webpack_require__("./node_modules/semver/functions/rcompare.js")
const compareLoose = __webpack_require__("./node_modules/semver/functions/compare-loose.js")
const compareBuild = __webpack_require__("./node_modules/semver/functions/compare-build.js")
const sort = __webpack_require__("./node_modules/semver/functions/sort.js")
const rsort = __webpack_require__("./node_modules/semver/functions/rsort.js")
const gt = __webpack_require__("./node_modules/semver/functions/gt.js")
const lt = __webpack_require__("./node_modules/semver/functions/lt.js")
const eq = __webpack_require__("./node_modules/semver/functions/eq.js")
const neq = __webpack_require__("./node_modules/semver/functions/neq.js")
const gte = __webpack_require__("./node_modules/semver/functions/gte.js")
const lte = __webpack_require__("./node_modules/semver/functions/lte.js")
const cmp = __webpack_require__("./node_modules/semver/functions/cmp.js")
const coerce = __webpack_require__("./node_modules/semver/functions/coerce.js")
const Comparator = __webpack_require__("./node_modules/semver/classes/comparator.js")
const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__("./node_modules/semver/functions/satisfies.js")
const toComparators = __webpack_require__("./node_modules/semver/ranges/to-comparators.js")
const maxSatisfying = __webpack_require__("./node_modules/semver/ranges/max-satisfying.js")
const minSatisfying = __webpack_require__("./node_modules/semver/ranges/min-satisfying.js")
const minVersion = __webpack_require__("./node_modules/semver/ranges/min-version.js")
const validRange = __webpack_require__("./node_modules/semver/ranges/valid.js")
const outside = __webpack_require__("./node_modules/semver/ranges/outside.js")
const gtr = __webpack_require__("./node_modules/semver/ranges/gtr.js")
const ltr = __webpack_require__("./node_modules/semver/ranges/ltr.js")
const intersects = __webpack_require__("./node_modules/semver/ranges/intersects.js")
const simplifyRange = __webpack_require__("./node_modules/semver/ranges/simplify.js")
const subset = __webpack_require__("./node_modules/semver/ranges/subset.js")
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/***/ (function(module) {



// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__("process/browser");


const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/***/ (function(module) {



const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/lrucache.js":
/***/ (function(module) {



class LRUCache {
  constructor () {
    this.max = 1000
    this.map = new Map()
  }

  get (key) {
    const value = this.map.get(key)
    if (value === undefined) {
      return undefined
    } else {
      // Remove the key from the map and add it to the end
      this.map.delete(key)
      this.map.set(key, value)
      return value
    }
  }

  delete (key) {
    return this.map.delete(key)
  }

  set (key, value) {
    const deleted = this.delete(key)

    if (!deleted && value !== undefined) {
      // If cache is full, delete the least recently used item
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value
        this.delete(firstKey)
      }

      this.map.set(key, value)
    }

    return this
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/***/ (function(module) {



// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/***/ (function(module, exports, __webpack_require__) {



const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = __webpack_require__("./node_modules/semver/internal/constants.js")
const debug = __webpack_require__("./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const safeSrc = exports.safeSrc = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  safeSrc[index] = safe
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
}|${src[t.NUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
}|${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
createToken('COERCEFULL', src[t.COERCEPLAIN] +
              `(?:${src[t.PRERELEASE]})?` +
              `(?:${src[t.BUILD]})?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)
createToken('COERCERTLFULL', src[t.COERCEFULL], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__("./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const outside = __webpack_require__("./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const Range = __webpack_require__("./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const gt = __webpack_require__("./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const SemVer = __webpack_require__("./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__("./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__("./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__("./node_modules/semver/functions/gt.js")
const lt = __webpack_require__("./node_modules/semver/functions/lt.js")
const lte = __webpack_require__("./node_modules/semver/functions/lte.js")
const gte = __webpack_require__("./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__("./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__("./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__("./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__("./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__("./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const Range = __webpack_require__("./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



const Range = __webpack_require__("./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2xlZGdlcmhxX2h3LXRyYW5zcG9ydC13ZWJ1c2JfbGliLWVzX1RyYW5zcG9ydFdlYlVTQl9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOztBQ3pJa0g7QUFDbEI7QUFDekYsaUNBQWlDLHNCQUFzQjtBQUN2RCw0QkFBNEIsc0JB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hQWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsd0NBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNUWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsd0NBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL0BsZWRnZXJocS9lcnJvcnMvbGliLWVzL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9AbGVkZ2VyaHEvZXJyb3JzL2xpYi1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL0BsZWRnZXJocS9ody10cmFuc3BvcnQvbGliLWVzL1RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL0BsZWRnZXJocS9kZXZpY2VzL2xpYi1lcy9oaWQtZnJhbWluZy5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL0BsZWRnZXJocS9kZXZpY2VzL2xpYi1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL0BsZWRnZXJocS9ody10cmFuc3BvcnQtd2VidXNiL2xpYi1lcy93ZWJ1c2IuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9AbGVkZ2VyaHEvaHctdHJhbnNwb3J0LXdlYnVzYi9saWItZXMvVHJhbnNwb3J0V2ViVVNCLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvQGxlZGdlcmhxL2xvZ3MvbGliLWVzL2luZGV4LmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvbHJ1Y2FjaGUuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcyIsIndlYnBhY2s6Ly9wYXljaW8td2FsbGV0Ly4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJ3ZWJwYWNrOi8vcGF5Y2lvLXdhbGxldC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwid2VicGFjazovL3BheWNpby13YWxsZXQvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb250aW51ZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbmNvbnN0IGVycm9yQ2xhc3NlcyA9IHt9O1xuY29uc3QgZGVzZXJpYWxpemVycyA9IHt9O1xuZXhwb3J0IGNvbnN0IGFkZEN1c3RvbUVycm9yRGVzZXJpYWxpemVyID0gKG5hbWUsIGRlc2VyaWFsaXplcikgPT4ge1xuICAgIGRlc2VyaWFsaXplcnNbbmFtZV0gPSBkZXNlcmlhbGl6ZXI7XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MgPSAobmFtZSkgPT4ge1xuICAgIGNsYXNzIEN1c3RvbUVycm9yQ2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNhdXNlO1xuICAgICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgbmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlcyNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDdXN0b21FcnJvckNsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXNba10gPSBmaWVsZHNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgaXNPYmplY3Qob3B0aW9ucykgJiYgXCJjYXVzZVwiIGluIG9wdGlvbnMgJiYgIXRoaXMuY2F1c2UpIHtcbiAgICAgICAgICAgICAgICAvLyAuY2F1c2Ugd2FzIHNwZWNpZmllZCBidXQgdGhlIHN1cGVyY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBkaWQgbm90IGNyZWF0ZSBhbiBpbnN0YW5jZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICBjb25zdCBjYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICAgICAgICAgIGlmIChcInN0YWNrXCIgaW4gY2F1c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2sgKyBcIlxcbkNBVVNFOiBcIiArIGNhdXNlLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvckNsYXNzZXNbbmFtZV0gPSBDdXN0b21FcnJvckNsYXNzO1xuICAgIHJldHVybiBDdXN0b21FcnJvckNsYXNzO1xufTtcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Byb2dyYW1ibGUvZXJyaW8vYmxvYi9tYXN0ZXIvaW5kZXguanNcbmV4cG9ydCBjb25zdCBkZXNlcmlhbGl6ZUVycm9yID0gKG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2Uob2JqZWN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSAmJiBtc2cubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBtc2c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IG9iamVjdDtcbiAgICAgICAgICAgIGNvbnN0IGRlcyA9IGRlc2VyaWFsaXplcnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoZGVzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBkZXMob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9IG5hbWUgPT09IFwiRXJyb3JcIiA/IEVycm9yIDogZXJyb3JDbGFzc2VzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZGVzZXJpYWxpemluZyBhbiB1bmtub3duIGNsYXNzICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW3Byb3BdID0gb2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBzZXR0aW5nIGEgcHJvcGVydHkgY2FuIGZhaWwgKGUuZy4gLm5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG9iamVjdC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIWVycm9yLnN0YWNrICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgZGVzZXJpYWxpemVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhvYmplY3QpKTtcbn07XG4vLyBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2VyaWFsaXplLWVycm9yL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZGVzdHJveUNpcmN1bGFyKHZhbHVlLCBbXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYFtGdW5jdGlvbjogJHt2YWx1ZS5uYW1lIHx8IFwiYW5vbnltb3VzXCJ9XWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZXN0cm95LWNpcmN1bGFyXG5mdW5jdGlvbiBkZXN0cm95Q2lyY3VsYXIoZnJvbSwgc2Vlbikge1xuICAgIGNvbnN0IHRvID0ge307XG4gICAgc2Vlbi5wdXNoKGZyb20pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZyb20pKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZnJvbVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKGZyb21ba2V5XSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0b1trZXldID0gZGVzdHJveUNpcmN1bGFyKGZyb21ba2V5XSwgc2Vlbi5zbGljZSgwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b1trZXldID0gXCJbQ2lyY3VsYXJdXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbS5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRvLm5hbWUgPSBmcm9tLm5hbWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbS5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRvLm1lc3NhZ2UgPSBmcm9tLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbS5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0by5zdGFjayA9IGZyb20uc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIiwiaW1wb3J0IHsgc2VyaWFsaXplRXJyb3IsIGRlc2VyaWFsaXplRXJyb3IsIGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MsIGFkZEN1c3RvbUVycm9yRGVzZXJpYWxpemVyLCB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmV4cG9ydCB7IHNlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yLCBjcmVhdGVDdXN0b21FcnJvckNsYXNzLCBhZGRDdXN0b21FcnJvckRlc2VyaWFsaXplciB9O1xuZXhwb3J0IGNvbnN0IEFjY291bnROYW1lUmVxdWlyZWRFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJBY2NvdW50TmFtZVJlcXVpcmVkXCIpO1xuZXhwb3J0IGNvbnN0IEFjY291bnROb3RTdXBwb3J0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQWNjb3VudE5vdFN1cHBvcnRlZFwiKTtcbmV4cG9ydCBjb25zdCBBY2NvdW50QXdhaXRpbmdTZW5kUGVuZGluZ09wZXJhdGlvbnMgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQWNjb3VudEF3YWl0aW5nU2VuZFBlbmRpbmdPcGVyYXRpb25zXCIpO1xuZXhwb3J0IGNvbnN0IEFtb3VudFJlcXVpcmVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkFtb3VudFJlcXVpcmVkXCIpO1xuZXhwb3J0IGNvbnN0IEJsdWV0b290aFJlcXVpcmVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkJsdWV0b290aFJlcXVpcmVkXCIpO1xuZXhwb3J0IGNvbnN0IEJ0Y1VubWF0Y2hlZEFwcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJCdGNVbm1hdGNoZWRBcHBcIik7XG5leHBvcnQgY29uc3QgQ2FudE9wZW5EZXZpY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ2FudE9wZW5EZXZpY2VcIik7XG5leHBvcnQgY29uc3QgQ2FzaEFkZHJOb3RTdXBwb3J0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ2FzaEFkZHJOb3RTdXBwb3J0ZWRcIik7XG5leHBvcnQgY29uc3QgQ2xhaW1SZXdhcmRzRmVlc1dhcm5pbmcgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ2xhaW1SZXdhcmRzRmVlc1dhcm5pbmdcIik7XG5leHBvcnQgY29uc3QgQ3VycmVuY3lOb3RTdXBwb3J0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ3VycmVuY3lOb3RTdXBwb3J0ZWRcIik7XG5leHBvcnQgY29uc3QgRGV2aWNlQXBwVmVyaWZ5Tm90U3VwcG9ydGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUFwcFZlcmlmeU5vdFN1cHBvcnRlZFwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VHZW51aW5lU29ja2V0RWFybHlDbG9zZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VHZW51aW5lU29ja2V0RWFybHlDbG9zZVwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VOb3RHZW51aW5lRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGV2aWNlTm90R2VudWluZVwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VPbkRhc2hib2FyZEV4cGVjdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZU9uRGFzaGJvYXJkRXhwZWN0ZWRcIik7XG5leHBvcnQgY29uc3QgRGV2aWNlT25EYXNoYm9hcmRVbmV4cGVjdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZU9uRGFzaGJvYXJkVW5leHBlY3RlZFwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VJbk9TVUV4cGVjdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUluT1NVRXhwZWN0ZWRcIik7XG5leHBvcnQgY29uc3QgRGV2aWNlSGFsdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUhhbHRlZFwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VOYW1lSW52YWxpZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VOYW1lSW52YWxpZFwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VTb2NrZXRGYWlsID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZVNvY2tldEZhaWxcIik7XG5leHBvcnQgY29uc3QgRGV2aWNlU29ja2V0Tm9CdWxrU3RhdHVzID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZVNvY2tldE5vQnVsa1N0YXR1c1wiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VOZWVkc1Jlc3RhcnQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGV2aWNlU29ja2V0Tm9CdWxrU3RhdHVzXCIpO1xuZXhwb3J0IGNvbnN0IFVucmVzcG9uc2l2ZURldmljZUVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVucmVzcG9uc2l2ZURldmljZUVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IERpc2Nvbm5lY3RlZERldmljZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEaXNjb25uZWN0ZWREZXZpY2VcIik7XG5leHBvcnQgY29uc3QgRGlzY29ubmVjdGVkRGV2aWNlRHVyaW5nT3BlcmF0aW9uID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRpc2Nvbm5lY3RlZERldmljZUR1cmluZ09wZXJhdGlvblwiKTtcbmV4cG9ydCBjb25zdCBEZXZpY2VFeHRyYWN0T25ib2FyZGluZ1N0YXRlRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGV2aWNlRXh0cmFjdE9uYm9hcmRpbmdTdGF0ZUVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IERldmljZU9uYm9hcmRpbmdTdGF0ZVBvbGxpbmdFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VPbmJvYXJkaW5nU3RhdGVQb2xsaW5nRXJyb3JcIik7XG5leHBvcnQgY29uc3QgRW5wb2ludENvbmZpZ0Vycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkVucG9pbnRDb25maWdcIik7XG5leHBvcnQgY29uc3QgRXRoQXBwUGxlYXNlRW5hYmxlQ29udHJhY3REYXRhID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkV0aEFwcFBsZWFzZUVuYWJsZUNvbnRyYWN0RGF0YVwiKTtcbmV4cG9ydCBjb25zdCBGZWVFc3RpbWF0aW9uRmFpbGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkZlZUVzdGltYXRpb25GYWlsZWRcIik7XG5leHBvcnQgY29uc3QgRmlybXdhcmVOb3RSZWNvZ25pemVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkZpcm13YXJlTm90UmVjb2duaXplZFwiKTtcbmV4cG9ydCBjb25zdCBIYXJkUmVzZXRGYWlsID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkhhcmRSZXNldEZhaWxcIik7XG5leHBvcnQgY29uc3QgSW52YWxpZFhSUFRhZyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJJbnZhbGlkWFJQVGFnXCIpO1xuZXhwb3J0IGNvbnN0IEludmFsaWRBZGRyZXNzID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkludmFsaWRBZGRyZXNzXCIpO1xuZXhwb3J0IGNvbnN0IEludmFsaWROb25jZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJJbnZhbGlkTm9uY2VcIik7XG5leHBvcnQgY29uc3QgSW52YWxpZEFkZHJlc3NCZWNhdXNlRGVzdGluYXRpb25Jc0Fsc29Tb3VyY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiSW52YWxpZEFkZHJlc3NCZWNhdXNlRGVzdGluYXRpb25Jc0Fsc29Tb3VyY2VcIik7XG5leHBvcnQgY29uc3QgTGF0ZXN0TUNVSW5zdGFsbGVkRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTGF0ZXN0TUNVSW5zdGFsbGVkRXJyb3JcIik7XG5leHBvcnQgY29uc3QgTGF0ZXN0RmlybXdhcmVWZXJzaW9uUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTGF0ZXN0RmlybXdhcmVWZXJzaW9uUmVxdWlyZWRcIik7XG5leHBvcnQgY29uc3QgVW5rbm93bk1DVSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVbmtub3duTUNVXCIpO1xuZXhwb3J0IGNvbnN0IExlZGdlckFQSUVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxlZGdlckFQSUVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IExlZGdlckFQSUVycm9yV2l0aE1lc3NhZ2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTGVkZ2VyQVBJRXJyb3JXaXRoTWVzc2FnZVwiKTtcbmV4cG9ydCBjb25zdCBMZWRnZXJBUElOb3RBdmFpbGFibGUgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTGVkZ2VyQVBJTm90QXZhaWxhYmxlXCIpO1xuZXhwb3J0IGNvbnN0IE1hbmFnZXJBcHBBbHJlYWR5SW5zdGFsbGVkRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckFwcEFscmVhZHlJbnN0YWxsZWRcIik7XG5leHBvcnQgY29uc3QgTWFuYWdlckFwcFJlbHlPbkJUQ0Vycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk1hbmFnZXJBcHBSZWx5T25CVENcIik7XG5leHBvcnQgY29uc3QgTWFuYWdlckFwcERlcEluc3RhbGxSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyQXBwRGVwSW5zdGFsbFJlcXVpcmVkXCIpO1xuZXhwb3J0IGNvbnN0IE1hbmFnZXJBcHBEZXBVbmluc3RhbGxSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyQXBwRGVwVW5pbnN0YWxsUmVxdWlyZWRcIik7XG5leHBvcnQgY29uc3QgTWFuYWdlckRldmljZUxvY2tlZEVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk1hbmFnZXJEZXZpY2VMb2NrZWRcIik7XG5leHBvcnQgY29uc3QgTWFuYWdlckZpcm13YXJlTm90RW5vdWdoU3BhY2VFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyRmlybXdhcmVOb3RFbm91Z2hTcGFjZVwiKTtcbmV4cG9ydCBjb25zdCBNYW5hZ2VyTm90RW5vdWdoU3BhY2VFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyTm90RW5vdWdoU3BhY2VcIik7XG5leHBvcnQgY29uc3QgTWFuYWdlclVuaW5zdGFsbEJUQ0RlcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyVW5pbnN0YWxsQlRDRGVwXCIpO1xuZXhwb3J0IGNvbnN0IE5ldHdvcmtEb3duID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5ldHdvcmtEb3duXCIpO1xuZXhwb3J0IGNvbnN0IE5ldHdvcmtFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOZXR3b3JrRXJyb3JcIik7XG5leHBvcnQgY29uc3QgTm9BZGRyZXNzZXNGb3VuZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb0FkZHJlc3Nlc0ZvdW5kXCIpO1xuZXhwb3J0IGNvbnN0IE5vdEVub3VnaEJhbGFuY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoQmFsYW5jZVwiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hCYWxhbmNlRmVlcyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hCYWxhbmNlRmVlc1wiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hCYWxhbmNlU3dhcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hCYWxhbmNlU3dhcFwiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hCYWxhbmNlVG9EZWxlZ2F0ZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hCYWxhbmNlVG9EZWxlZ2F0ZVwiKTtcbmV4cG9ydCBjb25zdCBVbnN0YWtlTm90RW5vdWdoU3Rha2VkQmFsYW5jZUxlZnQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVW5zdGFrZU5vdEVub3VnaFN0YWtlZEJhbGFuY2VMZWZ0XCIpO1xuZXhwb3J0IGNvbnN0IFJlc3Rha2VOb3RFbm91Z2hTdGFrZWRCYWxhbmNlTGVmdCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJSZXN0YWtlTm90RW5vdWdoU3Rha2VkQmFsYW5jZUxlZnRcIik7XG5leHBvcnQgY29uc3QgTm90RW5vdWdoVG9SZXN0YWtlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5vdEVub3VnaFRvUmVzdGFrZVwiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hUb1Vuc3Rha2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoVG9VbnN0YWtlXCIpO1xuZXhwb3J0IGNvbnN0IE5vdEVub3VnaEJhbGFuY2VJblBhcmVudEFjY291bnQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoQmFsYW5jZUluUGFyZW50QWNjb3VudFwiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hTcGVuZGFibGVCYWxhbmNlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5vdEVub3VnaFNwZW5kYWJsZUJhbGFuY2VcIik7XG5leHBvcnQgY29uc3QgTm90RW5vdWdoQmFsYW5jZUJlY2F1c2VEZXN0aW5hdGlvbk5vdENyZWF0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoQmFsYW5jZUJlY2F1c2VEZXN0aW5hdGlvbk5vdENyZWF0ZWRcIik7XG5leHBvcnQgY29uc3QgTm90RW5vdWdoVG9TdGFrZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hUb1N0YWtlXCIpO1xuZXhwb3J0IGNvbnN0IE5vQWNjZXNzVG9DYW1lcmEgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm9BY2Nlc3NUb0NhbWVyYVwiKTtcbmV4cG9ydCBjb25zdCBOb3RFbm91Z2hHYXMgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoR2FzXCIpO1xuLy8gRXJyb3IgbWVzc2FnZSBzcGVjaWZpY2FsbHkgZm9yIHRoZSBQVFggc3dhcCBmbG93XG5leHBvcnQgY29uc3QgTm90RW5vdWdoR2FzU3dhcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hHYXNTd2FwXCIpO1xuZXhwb3J0IGNvbnN0IFRyb25FbXB0eUFjY291bnQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVHJvbkVtcHR5QWNjb3VudFwiKTtcbmV4cG9ydCBjb25zdCBNYXliZUtlZXBUcm9uQWNjb3VudEFsaXZlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk1heWJlS2VlcFRyb25BY2NvdW50QWxpdmVcIik7XG5leHBvcnQgY29uc3QgTm90U3VwcG9ydGVkTGVnYWN5QWRkcmVzcyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RTdXBwb3J0ZWRMZWdhY3lBZGRyZXNzXCIpO1xuZXhwb3J0IGNvbnN0IEdhc0xlc3NUaGFuRXN0aW1hdGUgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiR2FzTGVzc1RoYW5Fc3RpbWF0ZVwiKTtcbmV4cG9ydCBjb25zdCBQcmlvcml0eUZlZVRvb0xvdyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQcmlvcml0eUZlZVRvb0xvd1wiKTtcbmV4cG9ydCBjb25zdCBQcmlvcml0eUZlZVRvb0hpZ2ggPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUHJpb3JpdHlGZWVUb29IaWdoXCIpO1xuZXhwb3J0IGNvbnN0IFByaW9yaXR5RmVlSGlnaGVyVGhhbk1heEZlZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQcmlvcml0eUZlZUhpZ2hlclRoYW5NYXhGZWVcIik7XG5leHBvcnQgY29uc3QgTWF4RmVlVG9vTG93ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk1heEZlZVRvb0xvd1wiKTtcbmV4cG9ydCBjb25zdCBQYXNzd29yZHNEb250TWF0Y2hFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQYXNzd29yZHNEb250TWF0Y2hcIik7XG5leHBvcnQgY29uc3QgUGFzc3dvcmRJbmNvcnJlY3RFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQYXNzd29yZEluY29ycmVjdFwiKTtcbmV4cG9ydCBjb25zdCBSZWNvbW1lbmRTdWJBY2NvdW50c1RvRW1wdHkgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUmVjb21tZW5kU3ViQWNjb3VudHNUb0VtcHR5XCIpO1xuZXhwb3J0IGNvbnN0IFJlY29tbWVuZFVuZGVsZWdhdGlvbiA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJSZWNvbW1lbmRVbmRlbGVnYXRpb25cIik7XG5leHBvcnQgY29uc3QgVGltZW91dFRhZ2dlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJUaW1lb3V0VGFnZ2VkXCIpO1xuZXhwb3J0IGNvbnN0IFVuZXhwZWN0ZWRCb290bG9hZGVyID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVuZXhwZWN0ZWRCb290bG9hZGVyXCIpO1xuZXhwb3J0IGNvbnN0IE1DVU5vdEdlbnVpbmVUb0Rhc2hib2FyZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNQ1VOb3RHZW51aW5lVG9EYXNoYm9hcmRcIik7XG5leHBvcnQgY29uc3QgUmVjaXBpZW50UmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUmVjaXBpZW50UmVxdWlyZWRcIik7XG5leHBvcnQgY29uc3QgVW5hdmFpbGFibGVUZXpvc09yaWdpbmF0ZWRBY2NvdW50UmVjZWl2ZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVbmF2YWlsYWJsZVRlem9zT3JpZ2luYXRlZEFjY291bnRSZWNlaXZlXCIpO1xuZXhwb3J0IGNvbnN0IFVuYXZhaWxhYmxlVGV6b3NPcmlnaW5hdGVkQWNjb3VudFNlbmQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVW5hdmFpbGFibGVUZXpvc09yaWdpbmF0ZWRBY2NvdW50U2VuZFwiKTtcbmV4cG9ydCBjb25zdCBVcGRhdGVGZXRjaEZpbGVGYWlsID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVwZGF0ZUZldGNoRmlsZUZhaWxcIik7XG5leHBvcnQgY29uc3QgVXBkYXRlSW5jb3JyZWN0SGFzaCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVcGRhdGVJbmNvcnJlY3RIYXNoXCIpO1xuZXhwb3J0IGNvbnN0IFVwZGF0ZUluY29ycmVjdFNpZyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVcGRhdGVJbmNvcnJlY3RTaWdcIik7XG5leHBvcnQgY29uc3QgVXBkYXRlWW91ckFwcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVcGRhdGVZb3VyQXBwXCIpO1xuZXhwb3J0IGNvbnN0IFVzZXJSZWZ1c2VkRGV2aWNlTmFtZUNoYW5nZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVc2VyUmVmdXNlZERldmljZU5hbWVDaGFuZ2VcIik7XG5leHBvcnQgY29uc3QgVXNlclJlZnVzZWRBZGRyZXNzID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVzZXJSZWZ1c2VkQWRkcmVzc1wiKTtcbmV4cG9ydCBjb25zdCBVc2VyUmVmdXNlZEZpcm13YXJlVXBkYXRlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVzZXJSZWZ1c2VkRmlybXdhcmVVcGRhdGVcIik7XG5leHBvcnQgY29uc3QgVXNlclJlZnVzZWRBbGxvd01hbmFnZXIgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVXNlclJlZnVzZWRBbGxvd01hbmFnZXJcIik7XG5leHBvcnQgY29uc3QgVXNlclJlZnVzZWRPbkRldmljZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVc2VyUmVmdXNlZE9uRGV2aWNlXCIpOyAvLyBUT0RPIHJlbmFtZSBiZWNhdXNlIGl0J3MganVzdCBmb3IgdHJhbnNhY3Rpb24gcmVmdXNhbFxuZXhwb3J0IGNvbnN0IFBpbk5vdFNldCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQaW5Ob3RTZXRcIik7XG5leHBvcnQgY29uc3QgRXhwZXJ0TW9kZVJlcXVpcmVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkV4cGVydE1vZGVSZXF1aXJlZFwiKTtcbmV4cG9ydCBjb25zdCBUcmFuc3BvcnRPcGVuVXNlckNhbmNlbGxlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJUcmFuc3BvcnRPcGVuVXNlckNhbmNlbGxlZFwiKTtcbmV4cG9ydCBjb25zdCBUcmFuc3BvcnRJbnRlcmZhY2VOb3RBdmFpbGFibGUgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVHJhbnNwb3J0SW50ZXJmYWNlTm90QXZhaWxhYmxlXCIpO1xuZXhwb3J0IGNvbnN0IFRyYW5zcG9ydFJhY2VDb25kaXRpb24gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVHJhbnNwb3J0UmFjZUNvbmRpdGlvblwiKTtcbmV4cG9ydCBjb25zdCBUcmFuc3BvcnRXZWJVU0JHZXN0dXJlUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVHJhbnNwb3J0V2ViVVNCR2VzdHVyZVJlcXVpcmVkXCIpO1xuZXhwb3J0IGNvbnN0IFRyYW5zYWN0aW9uSGFzQmVlblZhbGlkYXRlZEVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlRyYW5zYWN0aW9uSGFzQmVlblZhbGlkYXRlZEVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IFRyYW5zcG9ydEV4Y2hhbmdlVGltZW91dEVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlRyYW5zcG9ydEV4Y2hhbmdlVGltZW91dEVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IERldmljZVNob3VsZFN0YXlJbkFwcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VTaG91bGRTdGF5SW5BcHBcIik7XG5leHBvcnQgY29uc3QgV2Vic29ja2V0Q29ubmVjdGlvbkVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIldlYnNvY2tldENvbm5lY3Rpb25FcnJvclwiKTtcbmV4cG9ydCBjb25zdCBXZWJzb2NrZXRDb25uZWN0aW9uRmFpbGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIldlYnNvY2tldENvbm5lY3Rpb25GYWlsZWRcIik7XG5leHBvcnQgY29uc3QgV3JvbmdEZXZpY2VGb3JBY2NvdW50ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIldyb25nRGV2aWNlRm9yQWNjb3VudFwiKTtcbmV4cG9ydCBjb25zdCBXcm9uZ0RldmljZUZvckFjY291bnRQYXlvdXQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiV3JvbmdEZXZpY2VGb3JBY2NvdW50UGF5b3V0XCIpO1xuZXhwb3J0IGNvbnN0IE1pc3NpbmdTd2FwUGF5bG9hZFBhcmFtYXRlcnMgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWlzc2luZ1N3YXBQYXlsb2FkUGFyYW1hdGVyc1wiKTtcbmV4cG9ydCBjb25zdCBXcm9uZ0RldmljZUZvckFjY291bnRSZWZ1bmQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiV3JvbmdEZXZpY2VGb3JBY2NvdW50UmVmdW5kXCIpO1xuZXhwb3J0IGNvbnN0IFdyb25nQXBwRm9yQ3VycmVuY3kgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiV3JvbmdBcHBGb3JDdXJyZW5jeVwiKTtcbmV4cG9ydCBjb25zdCBFVEhBZGRyZXNzTm9uRUlQID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkVUSEFkZHJlc3NOb25FSVBcIik7XG5leHBvcnQgY29uc3QgQ2FudFNjYW5RUkNvZGUgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ2FudFNjYW5RUkNvZGVcIik7XG5leHBvcnQgY29uc3QgRmVlTm90TG9hZGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkZlZU5vdExvYWRlZFwiKTtcbmV4cG9ydCBjb25zdCBGZWVOb3RMb2FkZWRTd2FwID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkZlZU5vdExvYWRlZFN3YXBcIik7XG5leHBvcnQgY29uc3QgRmVlUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRmVlUmVxdWlyZWRcIik7XG5leHBvcnQgY29uc3QgRmVlVG9vSGlnaCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJGZWVUb29IaWdoXCIpO1xuZXhwb3J0IGNvbnN0IFBlbmRpbmdPcGVyYXRpb24gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUGVuZGluZ09wZXJhdGlvblwiKTtcbmV4cG9ydCBjb25zdCBTeW5jRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiU3luY0Vycm9yXCIpO1xuZXhwb3J0IGNvbnN0IFBhaXJpbmdGYWlsZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUGFpcmluZ0ZhaWxlZFwiKTtcbmV4cG9ydCBjb25zdCBQZWVyUmVtb3ZlZFBhaXJpbmcgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUGVlclJlbW92ZWRQYWlyaW5nXCIpO1xuZXhwb3J0IGNvbnN0IEdlbnVpbmVDaGVja0ZhaWxlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJHZW51aW5lQ2hlY2tGYWlsZWRcIik7XG5leHBvcnQgY29uc3QgTGVkZ2VyQVBJNHh4ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxlZGdlckFQSTR4eFwiKTtcbmV4cG9ydCBjb25zdCBMZWRnZXJBUEk1eHggPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTGVkZ2VyQVBJNXh4XCIpO1xuZXhwb3J0IGNvbnN0IEZpcm13YXJlT3JBcHBVcGRhdGVSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJGaXJtd2FyZU9yQXBwVXBkYXRlUmVxdWlyZWRcIik7XG4vLyBTcGVlZFVwIC8gQ2FuY2VsIEVWTSB0eFxuZXhwb3J0IGNvbnN0IFJlcGxhY2VtZW50VHJhbnNhY3Rpb25VbmRlcnByaWNlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJSZXBsYWNlbWVudFRyYW5zYWN0aW9uVW5kZXJwcmljZWRcIik7XG4vLyBCaXRjb2luIGZhbWlseVxuZXhwb3J0IGNvbnN0IE9wUmV0dXJuRGF0YVNpemVMaW1pdCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJPcFJldHVyblNpemVMaW1pdFwiKTtcbmV4cG9ydCBjb25zdCBEdXN0TGltaXQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRHVzdExpbWl0XCIpO1xuLy8gTGFuZ3VhZ2VcbmV4cG9ydCBjb25zdCBMYW5ndWFnZU5vdEZvdW5kID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxhbmd1YWdlTm90Rm91bmRcIik7XG4vLyBkYiBzdHVmZiwgbm8gbmVlZCB0byB0cmFuc2xhdGVcbmV4cG9ydCBjb25zdCBOb0RCUGF0aEdpdmVuID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5vREJQYXRoR2l2ZW5cIik7XG5leHBvcnQgY29uc3QgREJXcm9uZ1Bhc3N3b3JkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRCV3JvbmdQYXNzd29yZFwiKTtcbmV4cG9ydCBjb25zdCBEQk5vdFJlc2V0ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRCTm90UmVzZXRcIik7XG5leHBvcnQgY29uc3QgU2VxdWVuY2VOdW1iZXJFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJTZXF1ZW5jZU51bWJlckVycm9yXCIpO1xuZXhwb3J0IGNvbnN0IERpc2FibGVkVHJhbnNhY3Rpb25Ccm9hZGNhc3RFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEaXNhYmxlZFRyYW5zYWN0aW9uQnJvYWRjYXN0RXJyb3JcIik7XG4vKipcbiAqIFR5cGUgb2YgYSBUcmFuc3BvcnQgZXJyb3IgdXNlZCB0byByZXByZXNlbnQgYWxsIGVxdWl2YWxlbnQgZXJyb3JzIGNvbWluZyBmcm9tIGFsbCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiBvZiBUcmFuc3BvcnRcbiAqL1xuZXhwb3J0IHZhciBId1RyYW5zcG9ydEVycm9yVHlwZTtcbihmdW5jdGlvbiAoSHdUcmFuc3BvcnRFcnJvclR5cGUpIHtcbiAgICBId1RyYW5zcG9ydEVycm9yVHlwZVtcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcbiAgICBId1RyYW5zcG9ydEVycm9yVHlwZVtcIkxvY2F0aW9uU2VydmljZXNEaXNhYmxlZFwiXSA9IFwiTG9jYXRpb25TZXJ2aWNlc0Rpc2FibGVkXCI7XG4gICAgSHdUcmFuc3BvcnRFcnJvclR5cGVbXCJMb2NhdGlvblNlcnZpY2VzVW5hdXRob3JpemVkXCJdID0gXCJMb2NhdGlvblNlcnZpY2VzVW5hdXRob3JpemVkXCI7XG4gICAgSHdUcmFuc3BvcnRFcnJvclR5cGVbXCJCbHVldG9vdGhTY2FuU3RhcnRGYWlsZWRcIl0gPSBcIkJsdWV0b290aFNjYW5TdGFydEZhaWxlZFwiO1xufSkoSHdUcmFuc3BvcnRFcnJvclR5cGUgfHwgKEh3VHJhbnNwb3J0RXJyb3JUeXBlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciBjb21pbmcgZnJvbSB0aGUgdXNhZ2Ugb2YgYW55IFRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBOZWVkZWQgdG8gbWFwIGEgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZXJyb3IgaW50byBhbiBlcnJvciB0aGF0XG4gKiBjYW4gYmUgbWFuYWdlZCBieSBhbnkgY29kZSB1bmF3YXJlIG9mIHRoZSBzcGVjaWZpYyBUcmFuc3BvcnQgaW1wbGVtZW50YXRpb25cbiAqIHRoYXQgd2FzIHVzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBId1RyYW5zcG9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHR5cGU7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJId1RyYW5zcG9ydEVycm9yXCI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8vIE5lZWRlZCBhcyBsb25nIGFzIHdlIHRhcmdldCA8IEVTNlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSHdUcmFuc3BvcnRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNwb3J0RXJyb3IgaXMgdXNlZCBmb3IgYW55IGdlbmVyaWMgdHJhbnNwb3J0IGVycm9ycy5cbiAqIGUuZy4gRXJyb3IgdGhyb3duIHdoZW4gZGF0YSByZWNlaXZlZCBieSBleGNoYW5nZXMgYXJlIGluY29ycmVjdCBvciBpZiBleGNoYW5nZWQgZmFpbGVkIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGRldmljZSBmb3IgdmFyaW91cyByZWFzb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc3BvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBpZDtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gXCJUcmFuc3BvcnRFcnJvclwiO1xuICAgICAgICBzdXBlcihtZXNzYWdlIHx8IG5hbWUpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxufVxuYWRkQ3VzdG9tRXJyb3JEZXNlcmlhbGl6ZXIoXCJUcmFuc3BvcnRFcnJvclwiLCBlID0+IG5ldyBUcmFuc3BvcnRFcnJvcihlLm1lc3NhZ2UsIGUuaWQpKTtcbmV4cG9ydCBjb25zdCBTdGF0dXNDb2RlcyA9IHtcbiAgICBBQ0NFU1NfQ09ORElUSU9OX05PVF9GVUxGSUxMRUQ6IDB4OTgwNCxcbiAgICBBTEdPUklUSE1fTk9UX1NVUFBPUlRFRDogMHg5NDg0LFxuICAgIENMQV9OT1RfU1VQUE9SVEVEOiAweDZlMDAsXG4gICAgQ09ERV9CTE9DS0VEOiAweDk4NDAsXG4gICAgQ09ERV9OT1RfSU5JVElBTElaRUQ6IDB4OTgwMixcbiAgICBDT01NQU5EX0lOQ09NUEFUSUJMRV9GSUxFX1NUUlVDVFVSRTogMHg2OTgxLFxuICAgIENPTkRJVElPTlNfT0ZfVVNFX05PVF9TQVRJU0ZJRUQ6IDB4Njk4NSxcbiAgICBDT05UUkFESUNUSU9OX0lOVkFMSURBVElPTjogMHg5ODEwLFxuICAgIENPTlRSQURJQ1RJT05fU0VDUkVUX0NPREVfU1RBVFVTOiAweDk4MDgsXG4gICAgREVWSUNFX0lOX1JFQ09WRVJZX01PREU6IDB4NjYyZixcbiAgICBDVVNUT01fSU1BR0VfRU1QVFk6IDB4NjYyZSxcbiAgICBGSUxFX0FMUkVBRFlfRVhJU1RTOiAweDZhODksXG4gICAgRklMRV9OT1RfRk9VTkQ6IDB4OTQwNCxcbiAgICBHUF9BVVRIX0ZBSUxFRDogMHg2MzAwLFxuICAgIEhBTFRFRDogMHg2ZmFhLFxuICAgIElOQ09OU0lTVEVOVF9GSUxFOiAweDk0MDgsXG4gICAgSU5DT1JSRUNUX0RBVEE6IDB4NmE4MCxcbiAgICBJTkNPUlJFQ1RfTEVOR1RIOiAweDY3MDAsXG4gICAgSU5DT1JSRUNUX1AxX1AyOiAweDZiMDAsXG4gICAgSU5TX05PVF9TVVBQT1JURUQ6IDB4NmQwMCxcbiAgICBERVZJQ0VfTk9UX09OQk9BUkRFRDogMHg2ZDA3LFxuICAgIERFVklDRV9OT1RfT05CT0FSREVEXzI6IDB4NjYxMSxcbiAgICBJTlZBTElEX0tDVjogMHg5NDg1LFxuICAgIElOVkFMSURfT0ZGU0VUOiAweDk0MDIsXG4gICAgTElDRU5TSU5HOiAweDZmNDIsXG4gICAgTE9DS0VEX0RFVklDRTogMHg1NTE1LFxuICAgIE1BWF9WQUxVRV9SRUFDSEVEOiAweDk4NTAsXG4gICAgTUVNT1JZX1BST0JMRU06IDB4OTI0MCxcbiAgICBNSVNTSU5HX0NSSVRJQ0FMX1BBUkFNRVRFUjogMHg2ODAwLFxuICAgIE5PX0VGX1NFTEVDVEVEOiAweDk0MDAsXG4gICAgTk9UX0VOT1VHSF9NRU1PUllfU1BBQ0U6IDB4NmE4NCxcbiAgICBPSzogMHg5MDAwLFxuICAgIFBJTl9SRU1BSU5JTkdfQVRURU1QVFM6IDB4NjNjMCxcbiAgICBSRUZFUkVOQ0VEX0RBVEFfTk9UX0ZPVU5EOiAweDZhODgsXG4gICAgU0VDVVJJVFlfU1RBVFVTX05PVF9TQVRJU0ZJRUQ6IDB4Njk4MixcbiAgICBURUNITklDQUxfUFJPQkxFTTogMHg2ZjAwLFxuICAgIFVOS05PV05fQVBEVTogMHg2ZDAyLFxuICAgIFVTRVJfUkVGVVNFRF9PTl9ERVZJQ0U6IDB4NTUwMSxcbiAgICBOT1RfRU5PVUdIX1NQQUNFOiAweDUxMDIsXG4gICAgQVBQX05PVF9GT1VORF9PUl9JTlZBTElEX0NPTlRFWFQ6IDB4NTEyMyxcbiAgICBJTlZBTElEX0FQUF9OQU1FX0xFTkdUSDogMHg2NzBhLFxuICAgIEdFTl9BRVNfS0VZX0ZBSUxFRDogMHg1NDE5LFxuICAgIElOVEVSTkFMX0NSWVBUT19PUEVSQVRJT05fRkFJTEVEOiAweDU0MWEsXG4gICAgSU5URVJOQUxfQ09NUFVURV9BRVNfQ01BQ19GQUlMRUQ6IDB4NTQxYixcbiAgICBFTkNSWVBUX0FQUF9TVE9SQUdFX0ZBSUxFRDogMHg1NDFjLFxuICAgIElOVkFMSURfQkFDS1VQX1NUQVRFOiAweDY2NDIsXG4gICAgUElOX05PVF9TRVQ6IDB4NTUwMixcbiAgICBJTlZBTElEX0JBQ0tVUF9MRU5HVEg6IDB4NjczMyxcbiAgICBJTlZBTElEX1JFU1RPUkVfU1RBVEU6IDB4NjY0MyxcbiAgICBJTlZBTElEX0NIVU5LX0xFTkdUSDogMHg2NzM0LFxuICAgIElOVkFMSURfQkFDS1VQX0hFQURFUjogMHg2ODRhLFxuICAgIC8vIE5vdCBkb2N1bWVudGVkOlxuICAgIFRSVVNUQ0hBSU5fV1JPTkdfU0VFRDogMHhiMDA3LFxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbHRTdGF0dXNNZXNzYWdlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgLy8gaW1wcm92ZSB0ZXh0IG9mIG1vc3QgY29tbW9uIGVycm9yc1xuICAgICAgICBjYXNlIDB4NjcwMDpcbiAgICAgICAgICAgIHJldHVybiBcIkluY29ycmVjdCBsZW5ndGhcIjtcbiAgICAgICAgY2FzZSAweDY4MDA6XG4gICAgICAgICAgICByZXR1cm4gXCJNaXNzaW5nIGNyaXRpY2FsIHBhcmFtZXRlclwiO1xuICAgICAgICBjYXNlIDB4Njk4MjpcbiAgICAgICAgICAgIHJldHVybiBcIlNlY3VyaXR5IG5vdCBzYXRpc2ZpZWQgKGRvbmdsZSBsb2NrZWQgb3IgaGF2ZSBpbnZhbGlkIGFjY2VzcyByaWdodHMpXCI7XG4gICAgICAgIGNhc2UgMHg2OTg1OlxuICAgICAgICAgICAgcmV0dXJuIFwiQ29uZGl0aW9uIG9mIHVzZSBub3Qgc2F0aXNmaWVkIChkZW5pZWQgYnkgdGhlIHVzZXI/KVwiO1xuICAgICAgICBjYXNlIDB4NmE4MDpcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgZGF0YSByZWNlaXZlZFwiO1xuICAgICAgICBjYXNlIDB4NmIwMDpcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgcGFyYW1ldGVyIHJlY2VpdmVkXCI7XG4gICAgICAgIGNhc2UgMHg1NTE1OlxuICAgICAgICAgICAgcmV0dXJuIFwiTG9ja2VkIGRldmljZVwiO1xuICAgIH1cbiAgICBpZiAoMHg2ZjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFwiSW50ZXJuYWwgZXJyb3IsIHBsZWFzZSByZXBvcnRcIjtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgZGV2aWNlIHJldHVybmVkIGEgbm9uIHN1Y2Nlc3Mgc3RhdHVzLlxuICogdGhlIGVycm9yLnN0YXR1c0NvZGUgaXMgb25lIG9mIHRoZSBgU3RhdHVzQ29kZXNgIGV4cG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zcG9ydFN0YXR1c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXR1c0NvZGU7XG4gICAgc3RhdHVzVGV4dDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc3RhdHVzQ29kZSBUaGUgZXJyb3Igc3RhdHVzIGNvZGUgY29taW5nIGZyb20gYSBUcmFuc3BvcnQgaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWluaW5nOlxuICAgICAqICAtIGNhbkJlTWFwcGVkVG9DaGlsZEVycm9yOiBlbmFibGUgdGhlIG1hcHBpbmcgb2YgVHJhbnNwb3J0U3RhdHVzRXJyb3IgdG8gYW4gZXJyb3IgZXh0ZW5kaW5nL2luaGVyaXRpbmcgZnJvbSBpdFxuICAgICAqICAuIEV4OiBMb2NrZWREZXZpY2VFcnJvci4gRGVmYXVsdCB0byB0cnVlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHsgY2FuQmVNYXBwZWRUb0NoaWxkRXJyb3IgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gT2JqZWN0LmtleXMoU3RhdHVzQ29kZXMpLmZpbmQoayA9PiBTdGF0dXNDb2Rlc1trXSA9PT0gc3RhdHVzQ29kZSkgfHwgXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgICAgIGNvbnN0IHNtc2cgPSBnZXRBbHRTdGF0dXNNZXNzYWdlKHN0YXR1c0NvZGUpIHx8IHN0YXR1c1RleHQ7XG4gICAgICAgIGNvbnN0IHN0YXR1c0NvZGVTdHIgPSBzdGF0dXNDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBMZWRnZXIgZGV2aWNlOiAke3Ntc2d9ICgweCR7c3RhdHVzQ29kZVN0cn0pYDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiVHJhbnNwb3J0U3RhdHVzRXJyb3JcIjtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRyYW5zcG9ydFN0YXR1c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIC8vIE1hcHMgdG8gYSBMb2NrZWREZXZpY2VFcnJvclxuICAgICAgICBpZiAoY2FuQmVNYXBwZWRUb0NoaWxkRXJyb3IgJiYgc3RhdHVzQ29kZSA9PT0gU3RhdHVzQ29kZXMuTE9DS0VEX0RFVklDRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NrZWREZXZpY2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMb2NrZWREZXZpY2VFcnJvciBleHRlbmRzIFRyYW5zcG9ydFN0YXR1c0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKFN0YXR1c0NvZGVzLkxPQ0tFRF9ERVZJQ0UsIHsgY2FuQmVNYXBwZWRUb0NoaWxkRXJyb3I6IGZhbHNlIH0pO1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIkxvY2tlZERldmljZUVycm9yXCI7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBMb2NrZWREZXZpY2VFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZXZpY2VNYW5nZW1lbnRLaXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRGV2aWNlTWFuZ2VtZW50S2l0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5hZGRDdXN0b21FcnJvckRlc2VyaWFsaXplcihcIlRyYW5zcG9ydFN0YXR1c0Vycm9yXCIsIGUgPT4gbmV3IFRyYW5zcG9ydFN0YXR1c0Vycm9yKGUuc3RhdHVzQ29kZSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiZXZlbnRzXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnRSYWNlQ29uZGl0aW9uLCBUcmFuc3BvcnRFcnJvciwgU3RhdHVzQ29kZXMsIGdldEFsdFN0YXR1c01lc3NhZ2UsIFRyYW5zcG9ydFN0YXR1c0Vycm9yLCB9IGZyb20gXCJAbGVkZ2VyaHEvZXJyb3JzXCI7XG5pbXBvcnQgeyBMb2NhbFRyYWNlciB9IGZyb20gXCJAbGVkZ2VyaHEvbG9nc1wiO1xuZXhwb3J0IHsgVHJhbnNwb3J0RXJyb3IsIFRyYW5zcG9ydFN0YXR1c0Vycm9yLCBTdGF0dXNDb2RlcywgZ2V0QWx0U3RhdHVzTWVzc2FnZSB9O1xuY29uc3QgREVGQVVMVF9MT0dfVFlQRSA9IFwidHJhbnNwb3J0XCI7XG4vKipcbiAqIFRoZSBUcmFuc3BvcnQgY2xhc3MgZGVmaW5lcyBhIGdlbmVyaWMgaW50ZXJmYWNlIGZvciBjb21tdW5pY2F0aW5nIHdpdGggYSBMZWRnZXIgaGFyZHdhcmUgd2FsbGV0LlxuICogVGhlcmUgYXJlIGRpZmZlcmVudCBraW5kIG9mIHRyYW5zcG9ydHMgYmFzZWQgb24gdGhlIHRlY2hub2xvZ3kgKGNoYW5uZWxzIGxpa2UgVTJGLCBISUQsIEJsdWV0b290aCwgV2VidXNiKSBhbmQgZW52aXJvbm1lbnQgKE5vZGUsIFdlYiwuLi4pLlxuICogSXQgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNwb3J0IHtcbiAgICBleGNoYW5nZVRpbWVvdXQgPSAzMDAwMDtcbiAgICB1bnJlc3BvbnNpdmVUaW1lb3V0ID0gMTUwMDA7XG4gICAgZGV2aWNlTW9kZWwgPSBudWxsO1xuICAgIHRyYWNlcjtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbnRleHQsIGxvZ1R5cGUgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudHJhY2VyID0gbmV3IExvY2FsVHJhY2VyKGxvZ1R5cGUgPz8gREVGQVVMVF9MT0dfVFlQRSwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0cmFuc3BvcnQgaXMgc3VwcG9ydGVkIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtL2Jyb3dzZXIuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgc3VwcG9ydC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQ7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgYXZhaWxhYmxlIGRlc2NyaXB0b3JzIGZvciB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEZvciBhIGJldHRlciBncmFudWxhcml0eSwgY2hlY2tvdXQgYGxpc3RlbigpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGRlc2NyaXB0b3JzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVHJhbnNwb3J0Rm9vLmxpc3QoKS50aGVuKGRlc2NyaXB0b3JzID0+IC4uLilcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdDtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGRldmljZSBldmVudHMgZm9yIHRoZSB0cmFuc3BvcnQuIFRoZSBtZXRob2QgdGFrZXMgYW4gb2JzZXJ2ZXIgb2YgRGVzY3JpcHRvckV2ZW50IGFuZCByZXR1cm5zIGEgU3Vic2NyaXB0aW9uLlxuICAgICAqIEEgRGVzY3JpcHRvckV2ZW50IGlzIGFuIG9iamVjdCBjb250YWluaW5nIGEgXCJkZXNjcmlwdG9yXCIgYW5kIGEgXCJ0eXBlXCIgZmllbGQuIFRoZSBcInR5cGVcIiBmaWVsZCBjYW4gYmUgXCJhZGRcIiBvciBcInJlbW92ZVwiLCBhbmQgdGhlIFwiZGVzY3JpcHRvclwiIGZpZWxkIGNhbiBiZSBwYXNzZWQgdG8gdGhlIFwib3BlblwiIG1ldGhvZC5cbiAgICAgKiBUaGUgXCJsaXN0ZW5cIiBtZXRob2Qgd2lsbCBmaXJzdCBlbWl0IGFsbCBjdXJyZW50bHkgY29ubmVjdGVkIGRldmljZXMgYW5kIHRoZW4gd2lsbCBlbWl0IGV2ZW50cyBhcyB0aGV5IG9jY3VyLCBzdWNoIGFzIHdoZW4gYSBVU0IgZGV2aWNlIGlzIHBsdWdnZWQgaW4gb3IgYSBCbHVldG9vdGggZGV2aWNlIGJlY29tZXMgZGlzY292ZXJhYmxlLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXI8RGVzY3JpcHRvckV2ZW50PGFueT4+fSBvYnNlcnZlciAtIEFuIG9iamVjdCB3aXRoIFwibmV4dFwiLCBcImVycm9yXCIsIGFuZCBcImNvbXBsZXRlXCIgZnVuY3Rpb25zLCBmb2xsb3dpbmcgdGhlIG9ic2VydmVyIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbn0gQSBTdWJzY3JpcHRpb24gb2JqZWN0IG9uIHdoaWNoIHlvdSBjYW4gY2FsbCBcIi51bnN1YnNjcmliZSgpXCIgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZGVzY3JpcHRvcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICBjb25zdCBzdWIgPSBUcmFuc3BvcnRGb28ubGlzdGVuKHtcbiAgICBuZXh0OiBlID0+IHtcbiAgICAgIGlmIChlLnR5cGU9PT1cImFkZFwiKSB7XG4gICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBhd2FpdCBUcmFuc3BvcnRGb28ub3BlbihlLmRlc2NyaXB0b3IpO1xuICAgICAgICAuLi5cbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yOiBlcnJvciA9PiB7fSxcbiAgICBjb21wbGV0ZTogKCkgPT4ge31cbiAgICB9KVxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0ZW47XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjcmVhdGUgYSBUcmFuc3BvcnQgaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmljIGRlc2NyaXB0b3IuXG4gICAgICogQHBhcmFtIHthbnl9IGRlc2NyaXB0b3IgLSBUaGUgZGVzY3JpcHRvciB0byBvcGVuIHRoZSB0cmFuc3BvcnQgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIEFuIG9wdGlvbmFsIHRpbWVvdXQgZm9yIHRoZSB0cmFuc3BvcnQgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge1RyYWNlQ29udGV4dH0gY29udGV4dCBPcHRpb25hbCB0cmFjaW5nL2xvZyBjb250ZXh0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNwb3J0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIFRyYW5zcG9ydCBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgIFRyYW5zcG9ydEZvby5vcGVuKGRlc2NyaXB0b3IpLnRoZW4odHJhbnNwb3J0ID0+IC4uLilcbiAgICAgKi9cbiAgICBzdGF0aWMgb3BlbjtcbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgdG8gdGhlIGRldmljZSB1c2luZyBhIGxvdyBsZXZlbCBBUEkuXG4gICAgICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIFwic2VuZFwiIG1ldGhvZCBmb3IgYSBoaWdoZXIgbGV2ZWwgQVBJLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBhcGR1IC0gVGhlIGRhdGEgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbnRhaW5zIG9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBleGNoYW5nZSBmdW5jdGlvblxuICAgICAqICAtIGFib3J0VGltZW91dE1zOiBzdG9wIHRoZSBleGNoYW5nZSBhZnRlciBhIGdpdmVuIHRpbWVvdXQuIEFub3RoZXIgdGltZW91dCBleGlzdHNcbiAgICAgKiAgICB0byBkZXRlY3QgdW5yZXNwb25zaXZlIGRldmljZSAoc2VlIGB1bnJlc3BvbnNpdmVUaW1lb3V0YCkuIFRoaXMgdGltZW91dCBhYm9ydHMgdGhlIGV4Y2hhbmdlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgZGV2aWNlLlxuICAgICAqL1xuICAgIGV4Y2hhbmdlKF9hcGR1LCB7IGFib3J0VGltZW91dE1zOiBfYWJvcnRUaW1lb3V0TXMgfSA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4Y2hhbmdlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhcGR1cyBpbiBiYXRjaCB0byB0aGUgZGV2aWNlIHVzaW5nIGEgbG93IGxldmVsIEFQSS5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyB0byBjYWxsIGV4Y2hhbmdlIGZvciBlYWNoIGFwZHUuXG4gICAgICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBhcGR1cyAtIGFycmF5IG9mIGFwZHVzIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcjxCdWZmZXI+fSBvYnNlcnZlciAtIGFuIG9ic2VydmVyIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXNwb25zZSBvZiBlYWNoIGFwZHUuXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbn0gQSBTdWJzY3JpcHRpb24gb2JqZWN0IG9uIHdoaWNoIHlvdSBjYW4gY2FsbCBcIi51bnN1YnNjcmliZSgpXCIgdG8gc3RvcCBzZW5kaW5nIGFwZHVzLlxuICAgICAqL1xuICAgIGV4Y2hhbmdlQnVsayhhcGR1cywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgbGV0IHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1haW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodW5zdWJzY3JpYmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXBkdSBvZiBhcGR1cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmV4Y2hhbmdlKGFwZHUpO1xuICAgICAgICAgICAgICAgIGlmICh1bnN1YnNjcmliZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByLnJlYWRVSW50MTZCRShyLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IFN0YXR1c0NvZGVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRTdGF0dXNFcnJvcihzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtYWluKCkudGhlbigoKSA9PiAhdW5zdWJzY3JpYmVkICYmIG9ic2VydmVyLmNvbXBsZXRlKCksIGUgPT4gIXVuc3Vic2NyaWJlZCAmJiBvYnNlcnZlci5lcnJvcihlKSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgXCJzY3JhbWJsZSBrZXlcIiBmb3IgdGhlIG5leHQgZGF0YSBleGNoYW5nZXMgd2l0aCB0aGUgZGV2aWNlLlxuICAgICAqIEVhY2ggYXBwIGNhbiBoYXZlIGEgZGlmZmVyZW50IHNjcmFtYmxlIGtleSBhbmQgaXQgaXMgc2V0IGludGVybmFsbHkgZHVyaW5nIGluc3RhbnRpYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBzY3JhbWJsZSBrZXkgdG8gc2V0LlxuICAgICAqIGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgbm8gbG9uZ2VyIG5lZWRlZCBmb3IgbW9kZXJuIHRyYW5zcG9ydHMgYW5kIHNob3VsZCBiZSBtaWdyYXRlZCBhd2F5IGZyb20uXG4gICAgICogbm8gQCBiZWZvcmUgZGVwcmVjYXRlZCBhcyBpdCBicmVha3MgZG9jdW1lbnRhdGlvbmpzIG9uIHZlcnNpb24gMTQuMC4yXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2RvY3VtZW50YXRpb25qcy9kb2N1bWVudGF0aW9uL2lzc3Vlcy8xNTk2XG4gICAgICovXG4gICAgc2V0U2NyYW1ibGVLZXkoX2tleSkgeyB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgZGV2aWNlLlxuICAgICAqXG4gICAgICogTm90ZTogZm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoaHctdHJhbnNwb3J0LW5vZGUtaGlkLXNpbmdsZXRvbiBmb3IgZXgpLCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVkLFxuICAgICAqIHRoZSB0cmFuc3BvcnQgaW5zdGFuY2UgaXMgYWN0dWFsbHkgc3RpbGwgY2FjaGVkLCBhbmQgdGhlIGRldmljZSBpcyBkaXNjb25uZWN0ZWQgb25seSBhZnRlciBhIGRlZmluZWQgdGltZW91dC5cbiAgICAgKiBCdXQgZm9yIHRoZSBjb25zdW1lciBvZiB0aGUgVHJhbnNwb3J0LCB0aGlzIGRvZXMgbm90IG1hdHRlciBhbmQgaXQgY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgdG8gYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgX2V2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGFuIGV2ZW50IG9uIHRoZSB0cmFuc3BvcnQgaW5zdGFuY2UuXG4gICAgICogVHJhbnNwb3J0IGltcGxlbWVudGF0aW9ucyBtYXkgaGF2ZSBzcGVjaWZpYyBldmVudHMuIENvbW1vbiBldmVudHMgaW5jbHVkZTpcbiAgICAgKiBcImRpc2Nvbm5lY3RcIiA6IHRyaWdnZXJlZCB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgZGlzY29ubmVjdGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBhbnl9IGNiIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqL1xuICAgIG9uKGV2ZW50TmFtZSwgY2IpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLm9uKGV2ZW50TmFtZSwgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyB0byBhbiBldmVudCBvbiBhbiBpbnN0YW5jZSBvZiB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgb2ZmKGV2ZW50TmFtZSwgY2IpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgY2IpO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIG5vdCBsb2dzIG9mIHRoZSBiaW5hcnkgZXhjaGFuZ2VcbiAgICAgKi9cbiAgICBzZXREZWJ1Z01vZGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNldERlYnVnTW9kZSBpcyBkZXByZWNhdGVkLiB1c2UgQGxlZGdlcmhxL2xvZ3MgaW5zdGVhZC4gTm8gbG9ncyBhcmUgZW1pdHRlZCBpbiB0aGlzIGFueW1vcmUuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSB0aW1lb3V0IChpbiBtaWxsaXNlY29uZHMpIGZvciB0aGUgZXhjaGFuZ2UgY2FsbC4gT25seSBzb21lIHRyYW5zcG9ydCBtaWdodCBpbXBsZW1lbnQgaXQuIChlLmcuIFUyRilcbiAgICAgKi9cbiAgICBzZXRFeGNoYW5nZVRpbWVvdXQoZXhjaGFuZ2VUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZXhjaGFuZ2VUaW1lb3V0ID0gZXhjaGFuZ2VUaW1lb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIGRlbGF5IGJlZm9yZSBlbWl0dGluZyBcInVucmVzcG9uc2l2ZVwiIG9uIGFuIGV4Y2hhbmdlIHRoYXQgZG9lcyBub3QgcmVzcG9uZFxuICAgICAqL1xuICAgIHNldEV4Y2hhbmdlVW5yZXNwb25zaXZlVGltZW91dCh1bnJlc3BvbnNpdmVUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMudW5yZXNwb25zaXZlVGltZW91dCA9IHVucmVzcG9uc2l2ZVRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSB0byB0aGUgZGV2aWNlIHVzaW5nIHRoZSBoaWdoZXIgbGV2ZWwgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsYSAtIFRoZSBpbnN0cnVjdGlvbiBjbGFzcyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlucyAtIFRoZSBpbnN0cnVjdGlvbiBjb2RlIGZvciB0aGUgY29tbWFuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcDEgLSBUaGUgZmlyc3QgcGFyYW1ldGVyIGZvciB0aGUgaW5zdHJ1Y3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHAyIC0gVGhlIHNlY29uZCBwYXJhbWV0ZXIgZm9yIHRoZSBpbnN0cnVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSAtIFRoZSBkYXRhIHRvIGJlIHNlbnQuIERlZmF1bHRzIHRvIGFuIGVtcHR5IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHN0YXR1c0xpc3QgLSBBIGxpc3Qgb2YgYWNjZXB0YWJsZSBzdGF0dXMgY29kZXMgZm9yIHRoZSByZXNwb25zZS4gRGVmYXVsdHMgdG8gW1N0YXR1c0NvZGVzLk9LXS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbnRhaW5zIG9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBleGNoYW5nZSBmdW5jdGlvblxuICAgICAqICAtIGFib3J0VGltZW91dE1zOiBzdG9wIHRoZSBzZW5kIGFmdGVyIGEgZ2l2ZW4gdGltZW91dC4gQW5vdGhlciB0aW1lb3V0IGV4aXN0c1xuICAgICAqICAgIHRvIGRldGVjdCB1bnJlc3BvbnNpdmUgZGV2aWNlIChzZWUgYHVucmVzcG9uc2l2ZVRpbWVvdXRgKS4gVGhpcyB0aW1lb3V0IGFib3J0cyB0aGUgZXhjaGFuZ2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBkZXZpY2UuXG4gICAgICovXG4gICAgc2VuZCA9IGFzeW5jIChjbGEsIGlucywgcDEsIHAyLCBkYXRhID0gQnVmZmVyLmFsbG9jKDApLCBzdGF0dXNMaXN0ID0gW1N0YXR1c0NvZGVzLk9LXSwgeyBhYm9ydFRpbWVvdXRNcyB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gdGhpcy50cmFjZXIud2l0aFVwZGF0ZWRDb250ZXh0KHsgZnVuY3Rpb246IFwic2VuZFwiIH0pO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPj0gMjU2KSB7XG4gICAgICAgICAgICB0cmFjZXIudHJhY2UoXCJkYXRhLmxlbmd0aCBleGNlZWRlZCAyNTYgYnl0ZXMgbGltaXRcIiwgeyBkYXRhTGVuZ3RoOiBkYXRhLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRFcnJvcihcImRhdGEubGVuZ3RoIGV4Y2VlZCAyNTYgYnl0ZXMgbGltaXQuIEdvdDogXCIgKyBkYXRhLmxlbmd0aCwgXCJEYXRhTGVuZ3RoVG9vQmlnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlci50cmFjZShcIlN0YXJ0aW5nIGFuIGV4Y2hhbmdlXCIsIHsgYWJvcnRUaW1lb3V0TXMgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGNoYW5nZShcbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGRhdGEgaXMgYWRkZWQgaW4gMSBieXRlIGp1c3QgYmVmb3JlIGBkYXRhYFxuICAgICAgICBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbY2xhLCBpbnMsIHAxLCBwMl0pLCBCdWZmZXIuZnJvbShbZGF0YS5sZW5ndGhdKSwgZGF0YV0pLCB7IGFib3J0VGltZW91dE1zIH0pO1xuICAgICAgICB0cmFjZXIudHJhY2UoXCJSZWNlaXZlZCByZXNwb25zZSBmcm9tIGV4Y2hhbmdlXCIpO1xuICAgICAgICBjb25zdCBzdyA9IHJlc3BvbnNlLnJlYWRVSW50MTZCRShyZXNwb25zZS5sZW5ndGggLSAyKTtcbiAgICAgICAgaWYgKCFzdGF0dXNMaXN0LnNvbWUocyA9PiBzID09PSBzdykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRTdGF0dXNFcnJvcihzdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY3JlYXRlKCkgYWxsb3dzIHRvIG9wZW4gdGhlIGZpcnN0IGRlc2NyaXB0b3IgYXZhaWxhYmxlIG9yXG4gICAgICogdGhyb3cgaWYgdGhlcmUgaXMgbm9uZSBvciBpZiB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICogVGhpcyBpcyBhIGxpZ2h0IGhlbHBlciwgYWx0ZXJuYXRpdmUgdG8gdXNpbmcgbGlzdGVuKCkgYW5kIG9wZW4oKSAodGhhdCB5b3UgbWF5IG5lZWQgZm9yIGFueSBtb3JlIGFkdmFuY2VkIHVzZWNhc2UpXG4gICAgICogQGV4YW1wbGVcbiAgICBUcmFuc3BvcnRGb28uY3JlYXRlKCkudGhlbih0cmFuc3BvcnQgPT4gLi4uKVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUob3BlblRpbWVvdXQgPSAzMDAwLCBsaXN0ZW5UaW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMubGlzdGVuKHtcbiAgICAgICAgICAgICAgICBuZXh0OiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5UaW1lb3V0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobGlzdGVuVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuKGUuZGVzY3JpcHRvciwgb3BlblRpbWVvdXQpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlblRpbWVvdXRJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsaXN0ZW5UaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuVGltZW91dElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxpc3RlblRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVHJhbnNwb3J0RXJyb3IodGhpcy5FcnJvck1lc3NhZ2VfTm9EZXZpY2VGb3VuZCwgXCJOb0RldmljZUZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlblRpbWVvdXRJZCA9IGxpc3RlblRpbWVvdXRcbiAgICAgICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUcmFuc3BvcnRFcnJvcih0aGlzLkVycm9yTWVzc2FnZV9MaXN0ZW5UaW1lb3V0LCBcIkxpc3RlblRpbWVvdXRcIikpO1xuICAgICAgICAgICAgICAgIH0sIGxpc3RlblRpbWVvdXQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQmxvY2tzIG90aGVyIGV4Y2hhbmdlIHRvIGhhcHBlbiBjb25jdXJyZW50bHlcbiAgICBleGNoYW5nZUJ1c3lQcm9taXNlO1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgdG8gbWFrZSBhbiBleGNoYW5nZSBcImF0b21pY1wiIChibG9ja2luZyBhbnkgb3RoZXIgZXhjaGFuZ2UpXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGhhbmRsZXMgXCJ1bnJlc3BvbnNpdmVuZXNzXCIgYnkgZW1pdHRpbmcgXCJ1bnJlc3BvbnNpdmVcIiBhbmQgXCJyZXNwb25zaXZlXCIgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgVGhlIGV4Y2hhbmdlIGpvYiwgdXNpbmcgdGhlIHRyYW5zcG9ydCB0byBydW5cbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgZ2l2ZW4gam9iXG4gICAgICovXG4gICAgYXN5bmMgZXhjaGFuZ2VBdG9taWNJbXBsKGYpIHtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gdGhpcy50cmFjZXIud2l0aFVwZGF0ZWRDb250ZXh0KHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBcImV4Y2hhbmdlQXRvbWljSW1wbFwiLFxuICAgICAgICAgICAgdW5yZXNwb25zaXZlVGltZW91dDogdGhpcy51bnJlc3BvbnNpdmVUaW1lb3V0LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZXhjaGFuZ2VCdXN5UHJvbWlzZSkge1xuICAgICAgICAgICAgdHJhY2VyLnRyYWNlKFwiQXRvbWljIGV4Y2hhbmdlIGlzIGFscmVhZHkgYnVzeVwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRSYWNlQ29uZGl0aW9uKFwiQW4gYWN0aW9uIHdhcyBhbHJlYWR5IHBlbmRpbmcgb24gdGhlIExlZGdlciBkZXZpY2UuIFBsZWFzZSBkZW55IG9yIHJlY29ubmVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0cyB0aGUgYXRvbWljIGd1YXJkXG4gICAgICAgIGxldCByZXNvbHZlQnVzeTtcbiAgICAgICAgY29uc3QgYnVzeVByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVCdXN5ID0gcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhjaGFuZ2VCdXN5UHJvbWlzZSA9IGJ1c3lQcm9taXNlO1xuICAgICAgICAvLyBUaGUgZGV2aWNlIHVucmVzcG9uc2l2ZW5lc3MgaGFuZGxlclxuICAgICAgICBsZXQgdW5yZXNwb25zaXZlUmVhY2hlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0cmFjZXIudHJhY2UoYFRpbWVvdXQgcmVhY2hlZCwgZW1pdHRpbmcgVHJhbnNwb3J0IGV2ZW50IFwidW5yZXNwb25zaXZlXCJgLCB7XG4gICAgICAgICAgICAgICAgdW5yZXNwb25zaXZlVGltZW91dDogdGhpcy51bnJlc3BvbnNpdmVUaW1lb3V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bnJlc3BvbnNpdmVSZWFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVucmVzcG9uc2l2ZVwiKTtcbiAgICAgICAgfSwgdGhpcy51bnJlc3BvbnNpdmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGYoKTtcbiAgICAgICAgICAgIGlmICh1bnJlc3BvbnNpdmVSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyLnRyYWNlKFwiRGV2aWNlIHdhcyB1bnJlc3BvbnNpdmUsIGVtaXR0aW5nIHJlc3BvbnNpdmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVzcG9uc2l2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmFjZXIudHJhY2UoXCJGaW5hbGl6ZSwgY2xlYXJpbmcgYnVzeSBndWFyZFwiKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlQnVzeSlcbiAgICAgICAgICAgICAgICByZXNvbHZlQnVzeSgpO1xuICAgICAgICAgICAgdGhpcy5leGNoYW5nZUJ1c3lQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvcmF0ZUFwcEFQSU1ldGhvZHMoc2VsZiwgbWV0aG9kcywgc2NyYW1ibGVLZXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIHNlbGZbbWV0aG9kTmFtZV0gPSB0aGlzLmRlY29yYXRlQXBwQVBJTWV0aG9kKG1ldGhvZE5hbWUsIHNlbGZbbWV0aG9kTmFtZV0sIHNlbGYsIHNjcmFtYmxlS2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXBwQVBJbG9jayA9IG51bGw7XG4gICAgZGVjb3JhdGVBcHBBUElNZXRob2QobWV0aG9kTmFtZSwgZiwgY3R4LCBzY3JhbWJsZUtleSkge1xuICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2FwcEFQSWxvY2sgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoX2FwcEFQSWxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFRyYW5zcG9ydEVycm9yKFwiTGVkZ2VyIERldmljZSBpcyBidXN5IChsb2NrIFwiICsgX2FwcEFQSWxvY2sgKyBcIilcIiwgXCJUcmFuc3BvcnRMb2NrZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBBUElsb2NrID0gbWV0aG9kTmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNjcmFtYmxlS2V5KHNjcmFtYmxlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZi5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwQVBJbG9jayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbnRleHQgdXNlZCBieSB0aGUgbG9nZ2luZy90cmFjaW5nIG1lY2hhbmlzbVxuICAgICAqXG4gICAgICogVXNlZnVsIHdoZW4gcmUtdXNpbmcgKGNhY2hlZCkgdGhlIHNhbWUgVHJhbnNwb3J0IGluc3RhbmNlLFxuICAgICAqIGJ1dCB3aXRoIGEgbmV3IHRyYWNpbmcgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IEEgVHJhY2VDb250ZXh0LCB0aGF0IGNhbiB1bmRlZmluZWQgdG8gcmVzZXQgdGhlIGNvbnRleHRcbiAgICAgKi9cbiAgICBzZXRUcmFjZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRoaXMudHJhY2VyLndpdGhDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb250ZXh0IHVzZWQgYnkgdGhlIGxvZ2dpbmcvdHJhY2luZyBtZWNoYW5pc21cbiAgICAgKlxuICAgICAqIFRoZSB1cGRhdGUgb25seSBvdmVycmlkZXMgdGhlIGtleS12YWx1ZSB0aGF0IGFyZSBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0VG9BZGQgQSBUcmFjZUNvbnRleHQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKi9cbiAgICB1cGRhdGVUcmFjZUNvbnRleHQoY29udGV4dFRvQWRkKSB7XG4gICAgICAgIHRoaXMudHJhY2VyLnVwZGF0ZUNvbnRleHQoY29udGV4dFRvQWRkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHJhY2luZyBjb250ZXh0IG9mIHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRUcmFjZUNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNlci5nZXRDb250ZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBFcnJvck1lc3NhZ2VfTGlzdGVuVGltZW91dCA9IFwiTm8gTGVkZ2VyIGRldmljZSBmb3VuZCAodGltZW91dClcIjtcbiAgICBzdGF0aWMgRXJyb3JNZXNzYWdlX05vRGV2aWNlRm91bmQgPSBcIk5vIExlZGdlciBkZXZpY2UgZm91bmRcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zcG9ydC5qcy5tYXAiLCJpbXBvcnQgeyBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCJAbGVkZ2VyaHEvZXJyb3JzXCI7XG5jb25zdCBUYWcgPSAweDA1O1xuZnVuY3Rpb24gYXNVSW50MTZCRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgYi53cml0ZVVJbnQxNkJFKHZhbHVlLCAwKTtcbiAgICByZXR1cm4gYjtcbn1cbmNvbnN0IGluaXRpYWxBY2MgPSB7XG4gICAgZGF0YTogQnVmZmVyLmFsbG9jKDApLFxuICAgIGRhdGFMZW5ndGg6IDAsXG4gICAgc2VxdWVuY2U6IDAsXG59O1xuLyoqXG4gKiBPYmplY3QgdG8gaGFuZGxlIEhJRCBmcmFtZXMgKGVuY29kaW5nIGFuZCBkZWNvZGluZylcbiAqXG4gKiBAcGFyYW0gY2hhbm5lbFxuICogQHBhcmFtIHBhY2tldFNpemUgVGhlIEhJRCBwcm90b2NvbCBwYWNrZXQgc2l6ZSBpbiBieXRlcyAodXN1YWxseSA2NClcbiAqL1xuY29uc3QgY3JlYXRlSElEZnJhbWluZyA9IChjaGFubmVsLCBwYWNrZXRTaXplKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZyYW1lcy9lbmNvZGVzIGFuIEFQRFUgbWVzc2FnZSBpbnRvIEhJRCBVU0IgcGFja2V0cy9mcmFtZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFwZHUgVGhlIEFQRFUgbWVzc2FnZSB0byBzZW5kLCBpbiBhIEJ1ZmZlciBjb250YWluaW5nIFtjbGEsIGlucywgcDEsIHAyLCBkYXRhIGxlbmd0aCwgZGF0YShpZiBub3QgZW1wdHkpXVxuICAgICAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBISUQgVVNCIGZyYW1lcyByZWFkeSB0byBiZSBzZW50XG4gICAgICAgICAqL1xuICAgICAgICBtYWtlQmxvY2tzKGFwZHUpIHtcbiAgICAgICAgICAgIC8vIEVuY29kZXMgdGhlIEFQRFUgbGVuZ3RoIGluIDIgYnl0ZXMgYmVmb3JlIHRoZSBBUERVIGl0c2VsZi5cbiAgICAgICAgICAgIC8vIFRoZSBsZW5ndGggaXMgbWVhc3VyZWQgYXMgdGhlIG51bWJlciBvZiBieXRlcy5cbiAgICAgICAgICAgIC8vIEFzIHRoZSBzaXplIG9mIHRoZSBBUERVIGBkYXRhYCBzaG91bGQgaGF2ZSBiZWVuIGFkZGVkIGluIDEgYnl0ZSBqdXN0IGJlZm9yZSBgZGF0YWAsXG4gICAgICAgICAgICAvLyB0aGUgbWluaW11bSBzaXplIG9mIGFuIEFQRFUgaXMgNSBieXRlcy5cbiAgICAgICAgICAgIGxldCBkYXRhID0gQnVmZmVyLmNvbmNhdChbYXNVSW50MTZCRShhcGR1Lmxlbmd0aCksIGFwZHVdKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IHBhY2tldFNpemUgLSA1O1xuICAgICAgICAgICAgY29uc3QgbmJCbG9ja3MgPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyBibG9ja1NpemUpO1xuICAgICAgICAgICAgLy8gRmlsbHMgZGF0YSB3aXRoIDAtcGFkZGluZ1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RhdGEsIEJ1ZmZlci5hbGxvYyhuYkJsb2NrcyAqIGJsb2NrU2l6ZSAtIGRhdGEubGVuZ3RoICsgMSkuZmlsbCgwKV0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iQmxvY2tzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkID0gQnVmZmVyLmFsbG9jKDUpO1xuICAgICAgICAgICAgICAgIGhlYWQud3JpdGVVSW50MTZCRShjaGFubmVsLCAwKTtcbiAgICAgICAgICAgICAgICBoZWFkLndyaXRlVUludDgoVGFnLCAyKTtcbiAgICAgICAgICAgICAgICBoZWFkLndyaXRlVUludDE2QkUoaSwgMyk7XG4gICAgICAgICAgICAgICAgLy8gYHNsaWNlYCBhbmQgbm90IGBzdWJhcnJheWA6IHRoaXMgbWlnaHQgbm90IGJlIGEgTm9kZSBCdWZmZXIsIGJ1dCBwcm9iYWJseSBvbmx5IGEgVWludDhBcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS5zbGljZShpICogYmxvY2tTaXplLCAoaSArIDEpICogYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaChCdWZmZXIuY29uY2F0KFtoZWFkLCBjaHVua10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja3M7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWR1Y2VzIEhJRCBVU0IgcGFja2V0cy9mcmFtZXMgdG8gb25lIHJlc3BvbnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWNjIFRoZSB2YWx1ZSByZXN1bHRpbmcgZnJvbSAoYWNjdW11bGF0aW5nKSB0aGUgcHJldmlvdXMgY2FsbCBvZiByZWR1Y2VSZXNwb25zZS5cbiAgICAgICAgICogICBPbiBmaXJzdCBjYWxsIGluaXRpYWxpemVkIHRvIGBpbml0aWFsQWNjYC4gVGhlIGFjY3VtdWxhdG9yIGVuYWJsZXMgaGFuZGxpbmcgbXVsdGktZnJhbWVzIG1lc3NhZ2VzLlxuICAgICAgICAgKiBAcGFyYW0gY2h1bmsgQ3VycmVudCBjaHVuayB0byByZWR1Y2UgaW50byBhY2N1bXVsYXRvclxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhY2N1bXVsYXRvciB2YWx1ZSB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgICovXG4gICAgICAgIHJlZHVjZVJlc3BvbnNlKGFjYywgY2h1bmspIHtcbiAgICAgICAgICAgIGxldCB7IGRhdGEsIGRhdGFMZW5ndGgsIHNlcXVlbmNlIH0gPSBhY2MgfHwgaW5pdGlhbEFjYztcbiAgICAgICAgICAgIGlmIChjaHVuay5yZWFkVUludDE2QkUoMCkgIT09IGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNwb3J0RXJyb3IoXCJJbnZhbGlkIGNoYW5uZWxcIiwgXCJJbnZhbGlkQ2hhbm5lbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHVuay5yZWFkVUludDgoMikgIT09IFRhZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRFcnJvcihcIkludmFsaWQgdGFnXCIsIFwiSW52YWxpZFRhZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHVuay5yZWFkVUludDE2QkUoMykgIT09IHNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zcG9ydEVycm9yKFwiSW52YWxpZCBzZXF1ZW5jZVwiLCBcIkludmFsaWRTZXF1ZW5jZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldHMgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgMXN0IGZyYW1lXG4gICAgICAgICAgICBpZiAoIWFjYykge1xuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGggPSBjaHVuay5yZWFkVUludDE2QkUoNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXF1ZW5jZSsrO1xuICAgICAgICAgICAgLy8gVGhlIHRvdGFsIGxlbmd0aCBvbiB0aGUgMXN0IGZyYW1lIHRha2VzIDIgbW9yZSBieXRlc1xuICAgICAgICAgICAgY29uc3QgY2h1bmtEYXRhID0gY2h1bmsuc2xpY2UoYWNjID8gNSA6IDcpO1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RhdGEsIGNodW5rRGF0YV0pO1xuICAgICAgICAgICAgLy8gUmVtb3ZlcyBhbnkgMCBwYWRkaW5nXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBkYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXNwb25zZSBtZXNzYWdlIHRoYXQgaGFzIGJlZW4gcmVkdWNlZCBmcm9tIHRoZSBISUQgVVNCIGZyYW1lc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWNjIFRoZSBhY2N1bXVsYXRvclxuICAgICAgICAgKiBAcmV0dXJucyBBIEJ1ZmZlciBjb250YWluaW5nIHRoZSBjbGVhbmVkIHJlc3BvbnNlIG1lc3NhZ2UsIG9yIG51bGwgaWYgbm8gcmVzcG9uc2UgbWVzc2FnZSwgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgICAgICAgKiAgIGFjY3VtdWxhdG9yIGlzIGluY29ycmVjdCAobWVzc2FnZSBsZW5ndGggaXMgbm90IHZhbGlkKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVkdWNlZFJlc3VsdChhY2MpIHtcbiAgICAgICAgICAgIGlmIChhY2MgJiYgYWNjLmRhdGFMZW5ndGggPT09IGFjYy5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhJRGZyYW1pbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaWQtZnJhbWluZy5qcy5tYXAiLCJpbXBvcnQgc2VtdmVyIGZyb20gXCJzZW12ZXJcIjtcbi8qKlxuICogVGhlIFVTQiBwcm9kdWN0IElEcyB3aWxsIGJlIGRlZmluZWQgYXMgTU1JSSwgZW5jb2RpbmcgYSBtb2RlbCAoTU0pIGFuZCBhbiBpbnRlcmZhY2UgYml0ZmllbGQgKElJKVxuICpcbiAqKiBNb2RlbFxuICogTGVkZ2VyIE5hbm8gUyA6IDB4MTBcbiAqIExlZGdlciBCbHVlIDogMHgwMFxuICogTGVkZ2VyIE5hbm8gWCA6IDB4NDBcbiAqXG4gKiogSW50ZXJmYWNlIHN1cHBvcnQgYml0ZmllbGRcbiAqIEdlbmVyaWMgSElEIDogMHgwMVxuICogS2V5Ym9hcmQgSElEIDogMHgwMlxuICogVTJGIDogMHgwNFxuICogQ0NJRCA6IDB4MDhcbiAqIFdlYlVTQiA6IDB4MTBcbiAqL1xuZXhwb3J0IGNvbnN0IElJR2VuZXJpY0hJRCA9IDB4MDE7XG5leHBvcnQgY29uc3QgSUlLZXlib2FyZEhJRCA9IDB4MDI7XG5leHBvcnQgY29uc3QgSUlVMkYgPSAweDA0O1xuZXhwb3J0IGNvbnN0IElJQ0NJRCA9IDB4MDg7XG5leHBvcnQgY29uc3QgSUlXZWJVU0IgPSAweDEwO1xuZXhwb3J0IHZhciBEZXZpY2VNb2RlbElkO1xuKGZ1bmN0aW9uIChEZXZpY2VNb2RlbElkKSB7XG4gICAgLyoqIExlZGdlciBCbHVlICovXG4gICAgRGV2aWNlTW9kZWxJZFtcImJsdWVcIl0gPSBcImJsdWVcIjtcbiAgICAvKiogTGVkZ2VyIE5hbm8gUyAqL1xuICAgIERldmljZU1vZGVsSWRbXCJuYW5vU1wiXSA9IFwibmFub1NcIjtcbiAgICAvKiogTGVkZ2VyIE5hbm8gUyBQbHVzICovXG4gICAgRGV2aWNlTW9kZWxJZFtcIm5hbm9TUFwiXSA9IFwibmFub1NQXCI7XG4gICAgLyoqIExlZGdlciBOYW5vIFggKi9cbiAgICBEZXZpY2VNb2RlbElkW1wibmFub1hcIl0gPSBcIm5hbm9YXCI7XG4gICAgLyoqIExlZGdlciBTdGF4ICovXG4gICAgRGV2aWNlTW9kZWxJZFtcInN0YXhcIl0gPSBcInN0YXhcIjtcbiAgICAvKiogTGVkZ2VyIEZsZXggKFwiZXVyb3BhXCIgaXMgdGhlIGludGVybmFsIG5hbWUpICovXG4gICAgRGV2aWNlTW9kZWxJZFtcImV1cm9wYVwiXSA9IFwiZXVyb3BhXCI7XG4gICAgLyoqIEFwZXggKi9cbiAgICBEZXZpY2VNb2RlbElkW1wiYXBleFwiXSA9IFwiYXBleFwiO1xufSkoRGV2aWNlTW9kZWxJZCB8fCAoRGV2aWNlTW9kZWxJZCA9IHt9KSk7XG5jb25zdCBkZXZpY2VzID0ge1xuICAgIFtEZXZpY2VNb2RlbElkLmJsdWVdOiB7XG4gICAgICAgIGlkOiBEZXZpY2VNb2RlbElkLmJsdWUsXG4gICAgICAgIHByb2R1Y3ROYW1lOiBcIkxlZGdlcsKgQmx1ZVwiLFxuICAgICAgICBwcm9kdWN0SWRNTTogMHgwMCxcbiAgICAgICAgbGVnYWN5VXNiUHJvZHVjdElkOiAweDAwMDAsXG4gICAgICAgIHVzYk9ubHk6IHRydWUsXG4gICAgICAgIG1lbW9yeVNpemU6IDQ4MCAqIDEwMjQsXG4gICAgICAgIG1hc2tzOiBbMHgzMTAwMDAwMCwgMHgzMTAxMDAwMF0sXG4gICAgICAgIGdldEJsb2NrU2l6ZTogKF9maXJ3YXJlVmVyc2lvbikgPT4gNCAqIDEwMjQsXG4gICAgfSxcbiAgICBbRGV2aWNlTW9kZWxJZC5uYW5vU106IHtcbiAgICAgICAgaWQ6IERldmljZU1vZGVsSWQubmFub1MsXG4gICAgICAgIHByb2R1Y3ROYW1lOiBcIkxlZGdlcsKgTmFub8KgU1wiLFxuICAgICAgICBwcm9kdWN0SWRNTTogMHgxMCxcbiAgICAgICAgbGVnYWN5VXNiUHJvZHVjdElkOiAweDAwMDEsXG4gICAgICAgIHVzYk9ubHk6IHRydWUsXG4gICAgICAgIG1lbW9yeVNpemU6IDMyMCAqIDEwMjQsXG4gICAgICAgIG1hc2tzOiBbMHgzMTEwMDAwMF0sXG4gICAgICAgIGdldEJsb2NrU2l6ZTogKGZpcm13YXJlVmVyc2lvbikgPT4gc2VtdmVyLmx0KHNlbXZlci5jb2VyY2UoZmlybXdhcmVWZXJzaW9uKSA/PyBcIlwiLCBcIjIuMC4wXCIpID8gNCAqIDEwMjQgOiAyICogMTAyNCxcbiAgICB9LFxuICAgIFtEZXZpY2VNb2RlbElkLm5hbm9YXToge1xuICAgICAgICBpZDogRGV2aWNlTW9kZWxJZC5uYW5vWCxcbiAgICAgICAgcHJvZHVjdE5hbWU6IFwiTGVkZ2VywqBOYW5vwqBYXCIsXG4gICAgICAgIHByb2R1Y3RJZE1NOiAweDQwLFxuICAgICAgICBsZWdhY3lVc2JQcm9kdWN0SWQ6IDB4MDAwNCxcbiAgICAgICAgdXNiT25seTogZmFsc2UsXG4gICAgICAgIG1lbW9yeVNpemU6IDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgbWFza3M6IFsweDMzMDAwMDAwXSxcbiAgICAgICAgZ2V0QmxvY2tTaXplOiAoX2ZpcndhcmVWZXJzaW9uKSA9PiA0ICogMTAyNCxcbiAgICAgICAgYmx1ZXRvb3RoU3BlYzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlcnZpY2VVdWlkOiBcIjEzZDYzNDAwLTJjOTctMDAwNC0wMDAwLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIG5vdGlmeVV1aWQ6IFwiMTNkNjM0MDAtMmM5Ny0wMDA0LTAwMDEtNGM2NTY0Njc2NTcyXCIsXG4gICAgICAgICAgICAgICAgd3JpdGVVdWlkOiBcIjEzZDYzNDAwLTJjOTctMDAwNC0wMDAyLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIHdyaXRlQ21kVXVpZDogXCIxM2Q2MzQwMC0yYzk3LTAwMDQtMDAwMy00YzY1NjQ2NzY1NzJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBbRGV2aWNlTW9kZWxJZC5uYW5vU1BdOiB7XG4gICAgICAgIGlkOiBEZXZpY2VNb2RlbElkLm5hbm9TUCxcbiAgICAgICAgcHJvZHVjdE5hbWU6IFwiTGVkZ2VyIE5hbm8gUyBQbHVzXCIsXG4gICAgICAgIHByb2R1Y3RJZE1NOiAweDUwLFxuICAgICAgICBsZWdhY3lVc2JQcm9kdWN0SWQ6IDB4MDAwNSxcbiAgICAgICAgdXNiT25seTogdHJ1ZSxcbiAgICAgICAgbWVtb3J5U2l6ZTogMTUzMyAqIDEwMjQsXG4gICAgICAgIG1hc2tzOiBbMHgzMzEwMDAwMF0sXG4gICAgICAgIGdldEJsb2NrU2l6ZTogKF9maXJtd2FyZVZlcnNpb24pID0+IDMyLFxuICAgIH0sXG4gICAgW0RldmljZU1vZGVsSWQuYXBleF06IHtcbiAgICAgICAgaWQ6IERldmljZU1vZGVsSWQuYXBleCxcbiAgICAgICAgcHJvZHVjdE5hbWU6IFwiTGVkZ2VyIEFwZXhcIixcbiAgICAgICAgcHJvZHVjdElkTU06IDB4ODAsXG4gICAgICAgIGxlZ2FjeVVzYlByb2R1Y3RJZDogMHgwMDA4LFxuICAgICAgICB1c2JPbmx5OiBmYWxzZSxcbiAgICAgICAgbWVtb3J5U2l6ZTogMTUzMyAqIDEwMjQsXG4gICAgICAgIG1hc2tzOiBbMHgzMzQwMDAwMF0sXG4gICAgICAgIGdldEJsb2NrU2l6ZTogKF9maXJtd2FyZVZlcnNpb24pID0+IDMyLFxuICAgICAgICBibHVldG9vdGhTcGVjOiBbXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIDEzRDYzNDAwLTJDOTctNjAwNC0wMDAxLTRDNjU2NDY3NjU3MiwgMTNENjM0MDAtMkM5Ny02MDA0LTAwMDItNEM2NTY0Njc2NTcyLCBhbmQgMTNENjM0MDAtMkM5Ny02MDA0LTAwMDMtNEM2NTY0Njc2NTcyIENoYXJhY3RlcmlzdGljcyBmb3IgU2VydmljZSAxM0Q2MzQwMC0yQzk3LTYwMDQtMDAwMC00QzY1NjQ2NzY1NzJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlcnZpY2VVdWlkOiBcIjEzZDYzNDAwLTJjOTctNjAwNC0wMDAwLTRjNjU2NDY3NjU3MlwiLCAvLyBXSUxMIENIQU5HRSwgZm9yIG5vdyBzYW1lIGFzIFN0YXhcbiAgICAgICAgICAgICAgICBub3RpZnlVdWlkOiBcIjEzZDYzNDAwLTJjOTctNjAwNC0wMDAxLTRjNjU2NDY3NjU3MlwiLCAvLyBXSUxMIENIQU5HRSwgZm9yIG5vdyBzYW1lIGFzIFN0YXhcbiAgICAgICAgICAgICAgICB3cml0ZVV1aWQ6IFwiMTNkNjM0MDAtMmM5Ny02MDA0LTAwMDItNGM2NTY0Njc2NTcyXCIsIC8vIFdJTEwgQ0hBTkdFLCBmb3Igbm93IHNhbWUgYXMgU3RheFxuICAgICAgICAgICAgICAgIHdyaXRlQ21kVXVpZDogXCIxM2Q2MzQwMC0yYzk3LTYwMDQtMDAwMy00YzY1NjQ2NzY1NzJcIiwgLy8gV0lMTCBDSEFOR0UsIGZvciBub3cgc2FtZSBhcyBTdGF4XG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgW0RldmljZU1vZGVsSWQuc3RheF06IHtcbiAgICAgICAgaWQ6IERldmljZU1vZGVsSWQuc3RheCxcbiAgICAgICAgcHJvZHVjdE5hbWU6IFwiTGVkZ2VywqBTdGF4XCIsXG4gICAgICAgIHByb2R1Y3RJZE1NOiAweDYwLFxuICAgICAgICBsZWdhY3lVc2JQcm9kdWN0SWQ6IDB4MDAwNixcbiAgICAgICAgdXNiT25seTogZmFsc2UsXG4gICAgICAgIG1lbW9yeVNpemU6IDE1MzMgKiAxMDI0LFxuICAgICAgICBtYXNrczogWzB4MzMyMDAwMDBdLFxuICAgICAgICBnZXRCbG9ja1NpemU6IChfZmlybXdhcmVWZXJzaW9uKSA9PiAzMixcbiAgICAgICAgYmx1ZXRvb3RoU3BlYzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlcnZpY2VVdWlkOiBcIjEzZDYzNDAwLTJjOTctNjAwNC0wMDAwLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIG5vdGlmeVV1aWQ6IFwiMTNkNjM0MDAtMmM5Ny02MDA0LTAwMDEtNGM2NTY0Njc2NTcyXCIsXG4gICAgICAgICAgICAgICAgd3JpdGVVdWlkOiBcIjEzZDYzNDAwLTJjOTctNjAwNC0wMDAyLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIHdyaXRlQ21kVXVpZDogXCIxM2Q2MzQwMC0yYzk3LTYwMDQtMDAwMy00YzY1NjQ2NzY1NzJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBbRGV2aWNlTW9kZWxJZC5ldXJvcGFdOiB7XG4gICAgICAgIGlkOiBEZXZpY2VNb2RlbElkLmV1cm9wYSxcbiAgICAgICAgcHJvZHVjdE5hbWU6IFwiTGVkZ2VywqBGbGV4XCIsXG4gICAgICAgIHByb2R1Y3RJZE1NOiAweDcwLFxuICAgICAgICBsZWdhY3lVc2JQcm9kdWN0SWQ6IDB4MDAwNyxcbiAgICAgICAgdXNiT25seTogZmFsc2UsXG4gICAgICAgIG1lbW9yeVNpemU6IDE1MzMgKiAxMDI0LFxuICAgICAgICBtYXNrczogWzB4MzMzMDAwMDBdLFxuICAgICAgICBnZXRCbG9ja1NpemU6IChfZmlybXdhcmVWZXJzaW9uKSA9PiAzMixcbiAgICAgICAgYmx1ZXRvb3RoU3BlYzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlcnZpY2VVdWlkOiBcIjEzZDYzNDAwLTJjOTctMzAwNC0wMDAwLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIG5vdGlmeVV1aWQ6IFwiMTNkNjM0MDAtMmM5Ny0zMDA0LTAwMDEtNGM2NTY0Njc2NTcyXCIsXG4gICAgICAgICAgICAgICAgd3JpdGVVdWlkOiBcIjEzZDYzNDAwLTJjOTctMzAwNC0wMDAyLTRjNjU2NDY3NjU3MlwiLFxuICAgICAgICAgICAgICAgIHdyaXRlQ21kVXVpZDogXCIxM2Q2MzQwMC0yYzk3LTMwMDQtMDAwMy00YzY1NjQ2NzY1NzJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbn07XG5jb25zdCBwcm9kdWN0TWFwID0ge1xuICAgIEJsdWU6IERldmljZU1vZGVsSWQuYmx1ZSxcbiAgICBcIk5hbm8gU1wiOiBEZXZpY2VNb2RlbElkLm5hbm9TLFxuICAgIFwiTmFubyBTIFBsdXNcIjogRGV2aWNlTW9kZWxJZC5uYW5vU1AsXG4gICAgXCJOYW5vIFhcIjogRGV2aWNlTW9kZWxJZC5uYW5vWCxcbiAgICBTdGF4OiBEZXZpY2VNb2RlbElkLnN0YXgsXG4gICAgRXVyb3BhOiBEZXZpY2VNb2RlbElkLmV1cm9wYSxcbn07XG5jb25zdCBkZXZpY2VzTGlzdCA9IE9iamVjdC52YWx1ZXMoZGV2aWNlcyk7XG4vKipcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBsZWRnZXJVU0JWZW5kb3JJZCA9IDB4MmM5Nztcbi8qKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERldmljZU1vZGVsID0gKGlkKSA9PiB7XG4gICAgY29uc3QgaW5mbyA9IGRldmljZXNbaWRdO1xuICAgIGlmICghaW5mbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGV2aWNlICdcIiArIGlkICsgXCInIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgIHJldHVybiBpbmZvO1xufTtcbi8qKlxuICogR2l2ZW4gYSBgdGFyZ2V0SWRgLCByZXR1cm4gdGhlIGRldmljZU1vZGVsIGFzc29jaWF0ZWQgdG8gaXQsXG4gKiBiYXNlZCBvbiB0aGUgZmlyc3QgdHdvIGJ5dGVzLlxuICovXG5leHBvcnQgY29uc3QgaWRlbnRpZnlUYXJnZXRJZCA9ICh0YXJnZXRJZCkgPT4ge1xuICAgIGNvbnN0IGRldmljZU1vZGVsID0gZGV2aWNlc0xpc3QuZmluZCgoeyBtYXNrcyB9KSA9PiBtYXNrcy5maW5kKG1hc2sgPT4gKHRhcmdldElkICYgMHhmZmZmMDAwMCkgPT09IG1hc2spKTtcbiAgICByZXR1cm4gZGV2aWNlTW9kZWw7XG59O1xuLyoqXG4gKiBGcm9tIGEgZ2l2ZW4gVVNCIHByb2R1Y3QgaWQsIHJldHVybiB0aGUgZGV2aWNlTW9kZWwgYXNzb2NpYXRlZCB0byBpdC5cbiAqXG4gKiBUaGUgbWFwcGluZyBmcm9tIHRoZSBwcm9kdWN0IGlkIGlzIG9ubHkgYmFzZWQgb24gdGhlIDIgbW9zdCBzaWduaWZpY2FudCBieXRlcy5cbiAqIEZvciBleGFtcGxlLCBTdGF4IGlzIGRlZmluZWQgd2l0aCBhIHByb2R1Y3QgaWQgb2YgMHg2MGlpLCBhIHByb2R1Y3QgaWQgMHg2MDExIHdvdWxkIGJlIG1hcHBlZCB0byBpdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlkZW50aWZ5VVNCUHJvZHVjdElkID0gKHVzYlByb2R1Y3RJZCkgPT4ge1xuICAgIGNvbnN0IGxlZ2FjeSA9IGRldmljZXNMaXN0LmZpbmQoZCA9PiBkLmxlZ2FjeVVzYlByb2R1Y3RJZCA9PT0gdXNiUHJvZHVjdElkKTtcbiAgICBpZiAobGVnYWN5KVxuICAgICAgICByZXR1cm4gbGVnYWN5O1xuICAgIGNvbnN0IG1tID0gdXNiUHJvZHVjdElkID4+IDg7XG4gICAgY29uc3QgZGV2aWNlTW9kZWwgPSBkZXZpY2VzTGlzdC5maW5kKGQgPT4gZC5wcm9kdWN0SWRNTSA9PT0gbW0pO1xuICAgIHJldHVybiBkZXZpY2VNb2RlbDtcbn07XG5leHBvcnQgY29uc3QgaWRlbnRpZnlQcm9kdWN0TmFtZSA9IChwcm9kdWN0TmFtZSkgPT4ge1xuICAgIGNvbnN0IGRldmljZU1vZGVsID0gZGV2aWNlc0xpc3QuZmluZChkID0+IGQuaWQgPT09IHByb2R1Y3RNYXBbcHJvZHVjdE5hbWVdKTtcbiAgICByZXR1cm4gZGV2aWNlTW9kZWw7XG59O1xuY29uc3QgYmx1ZXRvb3RoU2VydmljZXMgPSBbXTtcbmNvbnN0IHNlcnZpY2VVdWlkVG9JbmZvcyA9IHt9O1xuZm9yIChjb25zdCBpZCBpbiBkZXZpY2VzKSB7XG4gICAgY29uc3QgZGV2aWNlTW9kZWwgPSBkZXZpY2VzW2lkXTtcbiAgICBjb25zdCB7IGJsdWV0b290aFNwZWMgfSA9IGRldmljZU1vZGVsO1xuICAgIGlmIChibHVldG9vdGhTcGVjKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmx1ZXRvb3RoU3BlYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BlYyA9IGJsdWV0b290aFNwZWNbaV07XG4gICAgICAgICAgICBibHVldG9vdGhTZXJ2aWNlcy5wdXNoKHNwZWMuc2VydmljZVV1aWQpO1xuICAgICAgICAgICAgc2VydmljZVV1aWRUb0luZm9zW3NwZWMuc2VydmljZVV1aWRdID0gc2VydmljZVV1aWRUb0luZm9zW3NwZWMuc2VydmljZVV1aWQucmVwbGFjZSgvLS9nLCBcIlwiKV0gPSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlTW9kZWwsXG4gICAgICAgICAgICAgICAgLi4uc3BlYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCbHVldG9vdGhTZXJ2aWNlVXVpZHMgPSAoKSA9PiBibHVldG9vdGhTZXJ2aWNlcztcbi8qKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEluZm9zRm9yU2VydmljZVV1aWQgPSAodXVpZCkgPT4gc2VydmljZVV1aWRUb0luZm9zW3V1aWQudG9Mb3dlckNhc2UoKV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBsZWRnZXJVU0JWZW5kb3JJZCB9IGZyb20gXCJAbGVkZ2VyaHEvZGV2aWNlc1wiO1xuY29uc3QgbGVkZ2VyRGV2aWNlcyA9IFtcbiAgICB7XG4gICAgICAgIHZlbmRvcklkOiBsZWRnZXJVU0JWZW5kb3JJZCxcbiAgICB9LFxuXTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1ZXN0TGVkZ2VyRGV2aWNlKCkge1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IG5hdmlnYXRvci51c2IucmVxdWVzdERldmljZSh7XG4gICAgICAgIGZpbHRlcnM6IGxlZGdlckRldmljZXMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRldmljZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZWRnZXJEZXZpY2VzKCkge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IudXNiLmdldERldmljZXMoKTtcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLnZlbmRvcklkID09PSBsZWRnZXJVU0JWZW5kb3JJZCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Rmlyc3RMZWRnZXJEZXZpY2UoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdEZXZpY2VzID0gYXdhaXQgZ2V0TGVkZ2VyRGV2aWNlcygpO1xuICAgIGlmIChleGlzdGluZ0RldmljZXMubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nRGV2aWNlc1swXTtcbiAgICByZXR1cm4gcmVxdWVzdExlZGdlckRldmljZSgpO1xufVxuZXhwb3J0IGNvbnN0IGlzU3VwcG9ydGVkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCEhbmF2aWdhdG9yICYmICEhbmF2aWdhdG9yLnVzYiAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzYi5nZXREZXZpY2VzID09PSBcImZ1bmN0aW9uXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VidXNiLmpzLm1hcCIsImltcG9ydCBUcmFuc3BvcnQgZnJvbSBcIkBsZWRnZXJocS9ody10cmFuc3BvcnRcIjtcbmltcG9ydCBoaWRGcmFtaW5nIGZyb20gXCJAbGVkZ2VyaHEvZGV2aWNlcy9oaWQtZnJhbWluZ1wiO1xuaW1wb3J0IHsgaWRlbnRpZnlVU0JQcm9kdWN0SWQgfSBmcm9tIFwiQGxlZGdlcmhxL2RldmljZXNcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCJAbGVkZ2VyaHEvbG9nc1wiO1xuaW1wb3J0IHsgVHJhbnNwb3J0T3BlblVzZXJDYW5jZWxsZWQsIFRyYW5zcG9ydEludGVyZmFjZU5vdEF2YWlsYWJsZSwgVHJhbnNwb3J0V2ViVVNCR2VzdHVyZVJlcXVpcmVkLCBEaXNjb25uZWN0ZWREZXZpY2VEdXJpbmdPcGVyYXRpb24sIERpc2Nvbm5lY3RlZERldmljZSwgfSBmcm9tIFwiQGxlZGdlcmhxL2Vycm9yc1wiO1xuaW1wb3J0IHsgZ2V0TGVkZ2VyRGV2aWNlcywgZ2V0Rmlyc3RMZWRnZXJEZXZpY2UsIHJlcXVlc3RMZWRnZXJEZXZpY2UsIGlzU3VwcG9ydGVkIH0gZnJvbSBcIi4vd2VidXNiXCI7XG5jb25zdCBjb25maWd1cmF0aW9uVmFsdWUgPSAxO1xuY29uc3QgZW5kcG9pbnROdW1iZXIgPSAzO1xuLyoqXG4gKiBXZWJVU0IgVHJhbnNwb3J0IGltcGxlbWVudGF0aW9uXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IFRyYW5zcG9ydFdlYlVTQiBmcm9tIFwiQGxlZGdlcmhxL2h3LXRyYW5zcG9ydC13ZWJ1c2JcIjtcbiAqIC4uLlxuICogVHJhbnNwb3J0V2ViVVNCLmNyZWF0ZSgpLnRoZW4odHJhbnNwb3J0ID0+IC4uLilcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNwb3J0V2ViVVNCIGV4dGVuZHMgVHJhbnNwb3J0IHtcbiAgICBkZXZpY2U7XG4gICAgZGV2aWNlTW9kZWw7XG4gICAgY2hhbm5lbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZik7XG4gICAgcGFja2V0U2l6ZSA9IDY0O1xuICAgIGludGVyZmFjZU51bWJlcjtcbiAgICBjb25zdHJ1Y3RvcihkZXZpY2UsIGludGVyZmFjZU51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VOdW1iZXIgPSBpbnRlcmZhY2VOdW1iZXI7XG4gICAgICAgIHRoaXMuZGV2aWNlTW9kZWwgPSBpZGVudGlmeVVTQlByb2R1Y3RJZChkZXZpY2UucHJvZHVjdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgV2ViVVNCIHRyYW5zcG9ydCBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgV2ViVVNCIGRldmljZXMgdGhhdCB3YXMgcHJldmlvdXNseSBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0ID0gZ2V0TGVkZ2VyRGV2aWNlcztcbiAgICAvKipcbiAgICAgKiBBY3RpdmVseSBsaXN0ZW4gdG8gV2ViVVNCIGRldmljZXMgYW5kIGVtaXQgT05FIGRldmljZVxuICAgICAqIHRoYXQgd2FzIGVpdGhlciBhY2NlcHRlZCBiZWZvcmUsIGlmIG5vdCBpdCB3aWxsIHRyaWdnZXIgdGhlIG5hdGl2ZSBwZXJtaXNzaW9uIFVJLlxuICAgICAqXG4gICAgICogSW1wb3J0YW50OiBpdCBtdXN0IGJlIGNhbGxlZCBpbiB0aGUgY29udGV4dCBvZiBhIFVJIGNsaWNrIVxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0ZW4gPSAob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgbGV0IHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBnZXRGaXJzdExlZGdlckRldmljZSgpLnRoZW4oZGV2aWNlID0+IHtcbiAgICAgICAgICAgIGlmICghdW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlTW9kZWwgPSBpZGVudGlmeVVTQlByb2R1Y3RJZChkZXZpY2UucHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VNb2RlbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAod2luZG93LkRPTUV4Y2VwdGlvbiAmJiBlcnJvciBpbnN0YW5jZW9mIHdpbmRvdy5ET01FeGNlcHRpb24gJiYgZXJyb3IuY29kZSA9PT0gMTgpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgVHJhbnNwb3J0V2ViVVNCR2VzdHVyZVJlcXVpcmVkKGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBUcmFuc3BvcnRPcGVuVXNlckNhbmNlbGxlZChlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBjcmVhdGUoKSBleGNlcHQgaXQgd2lsbCBhbHdheXMgZGlzcGxheSB0aGUgZGV2aWNlIHBlcm1pc3Npb24gKGV2ZW4gaWYgc29tZSBkZXZpY2VzIGFyZSBhbHJlYWR5IGFjY2VwdGVkKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlID0gYXdhaXQgcmVxdWVzdExlZGdlckRldmljZSgpO1xuICAgICAgICByZXR1cm4gVHJhbnNwb3J0V2ViVVNCLm9wZW4oZGV2aWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBjcmVhdGUoKSBleGNlcHQgaXQgd2lsbCBuZXZlciBkaXNwbGF5IHRoZSBkZXZpY2UgcGVybWlzc2lvbiAoaXQgcmV0dXJucyBhIFByb21pc2U8P1RyYW5zcG9ydD4sIG51bGwgaWYgaXQgZmFpbHMgdG8gZmluZCBhIGRldmljZSkuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIG9wZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBnZXRMZWRnZXJEZXZpY2VzKCk7XG4gICAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gVHJhbnNwb3J0V2ViVVNCLm9wZW4oZGV2aWNlc1swXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIExlZGdlciB0cmFuc3BvcnQgd2l0aCBhIFVTQkRldmljZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBvcGVuKGRldmljZSkge1xuICAgICAgICBhd2FpdCBkZXZpY2Uub3BlbigpO1xuICAgICAgICBpZiAoZGV2aWNlLmNvbmZpZ3VyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGRldmljZS5zZWxlY3RDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZ3JhY2VmdWxseVJlc2V0RGV2aWNlKGRldmljZSk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gZGV2aWNlLmNvbmZpZ3VyYXRpb25zWzBdLmludGVyZmFjZXMuZmluZCgoeyBhbHRlcm5hdGVzIH0pID0+IGFsdGVybmF0ZXMuc29tZShhID0+IGEuaW50ZXJmYWNlQ2xhc3MgPT09IDI1NSkpO1xuICAgICAgICBpZiAoIWlmYWNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNwb3J0SW50ZXJmYWNlTm90QXZhaWxhYmxlKFwiTm8gV2ViVVNCIGludGVyZmFjZSBmb3VuZCBmb3IgeW91ciBMZWRnZXIgZGV2aWNlLiBQbGVhc2UgdXBncmFkZSBmaXJtd2FyZSBvciBjb250YWN0IHRlY2hzdXBwb3J0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmZhY2VOdW1iZXIgPSBpZmFjZS5pbnRlcmZhY2VOdW1iZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBkZXZpY2UuY2xhaW1JbnRlcmZhY2UoaW50ZXJmYWNlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgZGV2aWNlLmNsb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNwb3J0SW50ZXJmYWNlTm90QXZhaWxhYmxlKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydFdlYlVTQihkZXZpY2UsIGludGVyZmFjZU51bWJlcik7XG4gICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IGUgPT4ge1xuICAgICAgICAgICAgaWYgKGRldmljZSA9PT0gZS5kZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnVzYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fZW1pdERpc2Nvbm5lY3QobmV3IERpc2Nvbm5lY3RlZERldmljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBuYXZpZ2F0b3IudXNiLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIF9kaXNjb25uZWN0RW1pdHRlZCA9IGZhbHNlO1xuICAgIF9lbWl0RGlzY29ubmVjdCA9IChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNjb25uZWN0RW1pdHRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgdHJhbnNwb3J0IGRldmljZVxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4Y2hhbmdlQnVzeVByb21pc2U7XG4gICAgICAgIGF3YWl0IHRoaXMuZGV2aWNlLnJlbGVhc2VJbnRlcmZhY2UodGhpcy5pbnRlcmZhY2VOdW1iZXIpO1xuICAgICAgICBhd2FpdCBncmFjZWZ1bGx5UmVzZXREZXZpY2UodGhpcy5kZXZpY2UpO1xuICAgICAgICBhd2FpdCB0aGlzLmRldmljZS5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNoYW5nZSB3aXRoIHRoZSBkZXZpY2UgdXNpbmcgQVBEVSBwcm90b2NvbC5cbiAgICAgKiBAcGFyYW0gYXBkdVxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBvZiBhcGR1IHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgZXhjaGFuZ2UoYXBkdSkge1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgdGhpcy5leGNoYW5nZUF0b21pY0ltcGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFubmVsLCBwYWNrZXRTaXplIH0gPSB0aGlzO1xuICAgICAgICAgICAgbG9nKFwiYXBkdVwiLCBcIj0+IFwiICsgYXBkdS50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICAgICAgICBjb25zdCBmcmFtaW5nID0gaGlkRnJhbWluZyhjaGFubmVsLCBwYWNrZXRTaXplKTtcbiAgICAgICAgICAgIC8vIFdyaXRlLi4uXG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBmcmFtaW5nLm1ha2VCbG9ja3MoYXBkdSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGV2aWNlLnRyYW5zZmVyT3V0KGVuZHBvaW50TnVtYmVyLCBibG9ja3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZC4uLlxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGxldCBhY2M7XG4gICAgICAgICAgICB3aGlsZSAoIShyZXN1bHQgPSBmcmFtaW5nLmdldFJlZHVjZWRSZXN1bHQoYWNjKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5kZXZpY2UudHJhbnNmZXJJbihlbmRwb2ludE51bWJlciwgcGFja2V0U2l6ZSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShyLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBhY2MgPSBmcmFtaW5nLnJlZHVjZVJlc3BvbnNlKGFjYywgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZyhcImFwZHVcIiwgXCI8PSBcIiArIHJlc3VsdC50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGlmIChlICYmIGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5jbHVkZXMoXCJkaXNjb25uZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0RGlzY29ubmVjdChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGlzY29ubmVjdGVkRGV2aWNlRHVyaW5nT3BlcmF0aW9uKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHNldFNjcmFtYmxlS2V5KCkgeyB9XG59XG5hc3luYyBmdW5jdGlvbiBncmFjZWZ1bGx5UmVzZXREZXZpY2UoZGV2aWNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGV2aWNlLnJlc2V0KCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNwb3J0V2ViVVNCLmpzLm1hcCIsImxldCBpZCA9IDA7XG5jb25zdCBzdWJzY3JpYmVycyA9IFtdO1xuLyoqXG4gKiBMb2dzIHNvbWV0aGluZ1xuICpcbiAqIEBwYXJhbSB0eXBlIGEgbmFtZXNwYWNlZCBpZGVudGlmaWVyIG9mIHRoZSBsb2cgKGl0IGlzIG5vdCBhIGxldmVsIGxpa2UgXCJkZWJ1Z1wiLCBcImVycm9yXCIgYnV0IG1vcmUgbGlrZSBcImFwZHUtaW5cIiwgXCJhcGR1LW91dFwiLCBldGMuLi4pXG4gKiBAcGFyYW0gbWVzc2FnZSBhIGNsZWFyIG1lc3NhZ2Ugb2YgdGhlIGxvZyBhc3NvY2lhdGVkIHRvIHRoZSB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBsb2cgPSAodHlwZSwgbWVzc2FnZSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaWQ6IFN0cmluZygrK2lkKSxcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICB9O1xuICAgIGlmIChtZXNzYWdlKVxuICAgICAgICBvYmoubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgaWYgKGRhdGEpXG4gICAgICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBkaXNwYXRjaChvYmopO1xufTtcbi8qKlxuICogQSBzaW1wbGUgdHJhY2VyIGZ1bmN0aW9uLCBvbmx5IGV4cGFuZGluZyB0aGUgZXhpc3RpbmcgbG9nIGZ1bmN0aW9uXG4gKlxuICogSXRzIGdvYWwgaXMgdG8gY2FwdHVyZSBtb3JlIGNvbnRleHQgdGhhbiBhIGxvZyBmdW5jdGlvbi5cbiAqIFRoaXMgaXMgc2ltcGxlIGZvciBub3csIGJ1dCBjYW4gYmUgaW1wcm92ZWQgbGF0ZXIuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgQW55dGhpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZXh0IHdoZXJlIHRoZSBsb2cgb2NjdXJyZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYWNlID0gKHsgdHlwZSwgbWVzc2FnZSwgZGF0YSwgY29udGV4dCwgfSkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaWQ6IFN0cmluZygrK2lkKSxcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICB9O1xuICAgIGlmIChtZXNzYWdlKVxuICAgICAgICBvYmoubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgaWYgKGRhdGEpXG4gICAgICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBpZiAoY29udGV4dClcbiAgICAgICAgb2JqLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGRpc3BhdGNoKG9iaik7XG59O1xuLyoqXG4gKiBBIHNpbXBsZSB0cmFjZXIgY2xhc3MsIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXZvaWQgcmVwZXRpdGlvbiB3aGVuIHVzaW5nIHRoZSBgdHJhY2VgIGZ1bmN0aW9uXG4gKlxuICogSXRzIGdvYWwgaXMgdG8gY2FwdHVyZSBtb3JlIGNvbnRleHQgdGhhbiBhIGxvZyBmdW5jdGlvbi5cbiAqIFRoaXMgaXMgc2ltcGxlIGZvciBub3csIGJ1dCBjYW4gYmUgaW1wcm92ZWQgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHR5cGUgQSBnaXZlbiB0eXBlIChub3QgbGV2ZWwpIGZvciB0aGUgY3VycmVudCBsb2NhbCB0cmFjZXIgKFwiaHdcIiwgXCJ3aXRoRGV2aWNlXCIsIGV0Yy4pXG4gKiBAcGFyYW0gY29udGV4dCBBbnl0aGluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRleHQgd2hlcmUgdGhlIGxvZyBvY2N1cnJlZFxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxUcmFjZXIge1xuICAgIHR5cGU7XG4gICAgY29udGV4dDtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHRyYWNlKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgdHJhY2Uoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH1cbiAgICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0VG9BZGQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0geyAuLi50aGlzLmNvbnRleHQsIC4uLmNvbnRleHRUb0FkZCB9O1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICBzZXRUeXBlKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBMb2NhbFRyYWNlciB3aXRoIGFuIHVwZGF0ZWQgYHR5cGVgXG4gICAgICpcbiAgICAgKiBJdCBkb2VzIG5vdCBtdXRhdGUgdGhlIGNhbGxpbmcgaW5zdGFuY2UsIGJ1dCByZXR1cm5zIGEgbmV3IExvY2FsVHJhY2VyLFxuICAgICAqIGZvbGxvd2luZyBhIHNpbXBsZSBidWlsZGVyIHBhdHRlcm4uXG4gICAgICovXG4gICAgd2l0aFR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IExvY2FsVHJhY2VyKHR5cGUsIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTG9jYWxUcmFjZXIgd2l0aCBhIG5ldyBgY29udGV4dGBcbiAgICAgKlxuICAgICAqIEl0IGRvZXMgbm90IG11dGF0ZSB0aGUgY2FsbGluZyBpbnN0YW5jZSwgYnV0IHJldHVybnMgYSBuZXcgTG9jYWxUcmFjZXIsXG4gICAgICogZm9sbG93aW5nIGEgc2ltcGxlIGJ1aWxkZXIgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IEEgVHJhY2VDb250ZXh0LCB0aGF0IGNhbiB1bmRlZmluZWQgdG8gcmVzZXQgdGhlIGNvbnRleHRcbiAgICAgKi9cbiAgICB3aXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxUcmFjZXIodGhpcy50eXBlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBMb2NhbFRyYWNlciB3aXRoIGFuIHVwZGF0ZWQgYGNvbnRleHRgLFxuICAgICAqIG9uIHdoaWNoIGFuIGFkZGl0aW9uYWwgY29udGV4dCBpcyBtZXJnZWQgd2l0aCB0aGUgZXhpc3Rpbmcgb25lLlxuICAgICAqXG4gICAgICogSXQgZG9lcyBub3QgbXV0YXRlIHRoZSBjYWxsaW5nIGluc3RhbmNlLCBidXQgcmV0dXJucyBhIG5ldyBMb2NhbFRyYWNlcixcbiAgICAgKiBmb2xsb3dpbmcgYSBzaW1wbGUgYnVpbGRlciBwYXR0ZXJuLlxuICAgICAqL1xuICAgIHdpdGhVcGRhdGVkQ29udGV4dChjb250ZXh0VG9BZGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFRyYWNlcih0aGlzLnR5cGUsIHsgLi4udGhpcy5jb250ZXh0LCAuLi5jb250ZXh0VG9BZGQgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBZGRzIGEgc3Vic2NyaWJlcnMgdG8gdGhlIGVtaXR0ZWQgbG9ncy5cbiAqXG4gKiBAcGFyYW0gY2IgdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggZnV0dXJlIGxvZygpIHdpdGggdGhlIExvZyBvYmplY3RcbiAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUgdGhlIGxpc3RlbmVyXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0ZW4gPSAoY2IpID0+IHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBpID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYik7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gZXF1aXZhbGVudCBvZiBzdWJzY3JpYmVycy5zcGxpY2UoaSwgMSkgLy8gaHR0cHM6Ly90d2l0dGVyLmNvbS9SaWNoX0hhcnJpcy9zdGF0dXMvMTEyNTg1MDM5MTE1NTk2NTk1MlxuICAgICAgICAgICAgc3Vic2NyaWJlcnNbaV0gPSBzdWJzY3JpYmVyc1tzdWJzY3JpYmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5mdW5jdGlvbiBkaXNwYXRjaChsb2cpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyc1tpXShsb2cpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cuX19sZWRnZXJMb2dzTGlzdGVuID0gbGlzdGVuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgQ29tcGFyYXRvciB7XG4gIHN0YXRpYyBnZXQgQU5ZICgpIHtcbiAgICByZXR1cm4gQU5ZXG4gIH1cblxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wID0gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcgJylcbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzIHdoZXJlIG5vdGhpbmcgY2FuIHBvc3NpYmx5IGJlIGxvd2VyXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlID09PSAnPDAuMC4wLTAnIHx8IGNvbXAudmFsdWUgPT09ICc8MC4wLjAtMCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSB8fCBjb21wLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gaW5jcmVhc2luZyAoPiBvciA+PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGRlY3JlYXNpbmcgKDwgb3IgPD0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBzYW1lIFNlbVZlciBhbmQgYm90aCBzaWRlcyBhcmUgaW5jbHVzaXZlICg8PSBvciA+PSlcbiAgICBpZiAoXG4gICAgICAodGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbikgJiZcbiAgICAgIHRoaXMub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSAmJiBjb21wLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgbGVzcyB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGdyZWF0ZXIgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTUEFDRV9DSEFSQUNURVJTID0gL1xccysvZ1xuXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QgcmVkdWNlIGFsbCB3aGl0ZXNwYWNlIGFzIG11Y2ggYXMgcG9zc2libGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVseVxuICAgIC8vIG9uIHBvdGVudGlhbGx5IHNsb3cgcmVnZXhlcyBsaWtlIFxccyouIFRoaXMgaXMgdGhlbiBzdG9yZWQgYW5kIHVzZWQgZm9yXG4gICAgLy8gZnV0dXJlIGVycm9yIG1lc3NhZ2VzIGFzIHdlbGwuXG4gICAgdGhpcy5yYXcgPSByYW5nZS50cmltKCkucmVwbGFjZShTUEFDRV9DSEFSQUNURVJTLCAnICcpXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgb24gfHxcbiAgICB0aGlzLnNldCA9IHRoaXMucmF3XG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCByYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJ3x8J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy5zZXRbaV1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb21wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJyAnXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9IGNvbXBzW2tdLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygndGlsZGUgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY2FyZXQgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIGlmIChsb29zZSkge1xuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoY29tcCA9PiB7XG4gICAgICAgIGRlYnVnKCdsb29zZSBpbnZhbGlkIGZpbHRlcicsIGNvbXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChyZVt0LkNPTVBBUkFUT1JMT09TRV0pXG4gICAgICB9KVxuICAgIH1cbiAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdClcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2VMaXN0Lm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKSB7XG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIH1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2xydWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSgpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VDYXJldChjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIHByID0gJy0wJ1xuICAgICAgfVxuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG4vLyBUT0RPIGJ1aWxkP1xuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwcikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ2J1aWxkIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSB7XG4gICAgaWYgKHJlbGVhc2Uuc3RhcnRzV2l0aCgncHJlJykpIHtcbiAgICAgIGlmICghaWRlbnRpZmllciAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBpcyBlbXB0eScpXG4gICAgICB9XG4gICAgICAvLyBBdm9pZCBhbiBpbnZhbGlkIHNlbXZlciByZXN1bHRzXG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGAtJHtpZGVudGlmaWVyfWAubWF0Y2godGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5QUkVSRUxFQVNFTE9PU0VdIDogcmVbdC5QUkVSRUxFQVNFXSlcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSAhPT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyOiAke2lkZW50aWZpZXJ9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgICAvLyBwcmVwYXRjaC5cbiAgICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmVyc2lvbiAke3RoaXMucmF3fSBpcyBub3QgYSBwcmVyZWxlYXNlYClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6IHtcbiAgICAgICAgY29uc3QgYmFzZSA9IE51bWJlcihpZGVudGlmaWVyQmFzZSkgPyAxIDogMFxuXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2Jhc2VdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgPT09IHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykgJiYgaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goYmFzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgbGV0IHByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgYmFzZV1cbiAgICAgICAgICBpZiAoaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVyZWxlYXNlID0gW2lkZW50aWZpZXJdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXJlSWRlbnRpZmllcnModGhpcy5wcmVyZWxlYXNlWzBdLCBpZGVudGlmaWVyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5yYXcgPSB0aGlzLmZvcm1hdCgpXG4gICAgaWYgKHRoaXMuYnVpbGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhdyArPSBgKyR7dGhpcy5idWlsZC5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vbmVxJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9ndCcpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2d0ZScpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9sdGUnKVxuXG5jb25zdCBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgY29lcmNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBsZXQgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHJlW3QuQ09FUkNFRlVMTF0gOiByZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvLyBXaXRoIGluY2x1ZGVQcmVyZWxlYXNlIG9wdGlvbiBzZXQsICcxLjIuMy40LXJjJyB3YW50cyB0byBjb2VyY2UgJzIuMy40LXJjJywgbm90ICcyLjMuNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIGNvbnN0IGNvZXJjZVJ0bFJlZ2V4ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHJlW3QuQ09FUkNFUlRMRlVMTF0gOiByZVt0LkNPRVJDRVJUTF1cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IGNvZXJjZVJ0bFJlZ2V4LmV4ZWModmVyc2lvbikpICYmXG4gICAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIGNvZXJjZVJ0bFJlZ2V4Lmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG1ham9yID0gbWF0Y2hbMl1cbiAgY29uc3QgbWlub3IgPSBtYXRjaFszXSB8fCAnMCdcbiAgY29uc3QgcGF0Y2ggPSBtYXRjaFs0XSB8fCAnMCdcbiAgY29uc3QgcHJlcmVsZWFzZSA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNV0gPyBgLSR7bWF0Y2hbNV19YCA6ICcnXG4gIGNvbnN0IGJ1aWxkID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBtYXRjaFs2XSA/IGArJHttYXRjaFs2XX1gIDogJydcblxuICByZXR1cm4gcGFyc2UoYCR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9JHtwcmVyZWxlYXNlfSR7YnVpbGR9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZS5qcycpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGNvbnN0IHYxID0gcGFyc2UodmVyc2lvbjEsIG51bGwsIHRydWUpXG4gIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIsIG51bGwsIHRydWUpXG4gIGNvbnN0IGNvbXBhcmlzb24gPSB2MS5jb21wYXJlKHYyKVxuXG4gIGlmIChjb21wYXJpc29uID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHYxSGlnaGVyID0gY29tcGFyaXNvbiA+IDBcbiAgY29uc3QgaGlnaFZlcnNpb24gPSB2MUhpZ2hlciA/IHYxIDogdjJcbiAgY29uc3QgbG93VmVyc2lvbiA9IHYxSGlnaGVyID8gdjIgOiB2MVxuICBjb25zdCBoaWdoSGFzUHJlID0gISFoaWdoVmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aFxuICBjb25zdCBsb3dIYXNQcmUgPSAhIWxvd1ZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcblxuICBpZiAobG93SGFzUHJlICYmICFoaWdoSGFzUHJlKSB7XG4gICAgLy8gR29pbmcgZnJvbSBwcmVyZWxlYXNlIC0+IG5vIHByZXJlbGVhc2UgcmVxdWlyZXMgc29tZSBzcGVjaWFsIGNhc2luZ1xuXG4gICAgLy8gSWYgdGhlIGxvdyB2ZXJzaW9uIGhhcyBvbmx5IGEgbWFqb3IsIHRoZW4gaXQgd2lsbCBhbHdheXMgYmUgYSBtYWpvclxuICAgIC8vIFNvbWUgZXhhbXBsZXM6XG4gICAgLy8gMS4wLjAtMSAtPiAxLjAuMFxuICAgIC8vIDEuMC4wLTEgLT4gMS4xLjFcbiAgICAvLyAxLjAuMC0xIC0+IDIuMC4wXG4gICAgaWYgKCFsb3dWZXJzaW9uLnBhdGNoICYmICFsb3dWZXJzaW9uLm1pbm9yKSB7XG4gICAgICByZXR1cm4gJ21ham9yJ1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBtYWluIHBhcnQgaGFzIG5vIGRpZmZlcmVuY2VcbiAgICBpZiAobG93VmVyc2lvbi5jb21wYXJlTWFpbihoaWdoVmVyc2lvbikgPT09IDApIHtcbiAgICAgIGlmIChsb3dWZXJzaW9uLm1pbm9yICYmICFsb3dWZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgIHJldHVybiAnbWlub3InXG4gICAgICB9XG4gICAgICByZXR1cm4gJ3BhdGNoJ1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0aGUgYHByZWAgcHJlZml4IGlmIHdlIGFyZSBnb2luZyB0byBhIHByZXJlbGVhc2UgdmVyc2lvblxuICBjb25zdCBwcmVmaXggPSBoaWdoSGFzUHJlID8gJ3ByZScgOiAnJ1xuXG4gIGlmICh2MS5tYWpvciAhPT0gdjIubWFqb3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21ham9yJ1xuICB9XG5cbiAgaWYgKHYxLm1pbm9yICE9PSB2Mi5taW5vcikge1xuICAgIHJldHVybiBwcmVmaXggKyAnbWlub3InXG4gIH1cblxuICBpZiAodjEucGF0Y2ggIT09IHYyLnBhdGNoKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdwYXRjaCdcbiAgfVxuXG4gIC8vIGhpZ2ggYW5kIGxvdyBhcmUgcHJlbGVhc2VzXG4gIHJldHVybiAncHJlcmVsZWFzZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyQmFzZSA9IGlkZW50aWZpZXJcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICB2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyID8gdmVyc2lvbi52ZXJzaW9uIDogdmVyc2lvbixcbiAgICAgIG9wdGlvbnNcbiAgICApLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXRjaCA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgcHJlcmVsZWFzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlcmVsZWFzZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iLCIndXNlIHN0cmljdCdcblxuLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgaWRlbnRpZmllcnMgPSByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKVxuY29uc3QgdmFsaWQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpXG5jb25zdCBjbGVhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJylcbmNvbnN0IGluYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpXG5jb25zdCBkaWZmID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpXG5jb25zdCBtYWpvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJylcbmNvbnN0IG1pbm9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKVxuY29uc3QgcGF0Y2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpXG5jb25zdCBwcmVyZWxlYXNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpXG5jb25zdCByc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBjb2VyY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKVxuY29uc3QgbWF4U2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpXG5jb25zdCBtaW5WZXJzaW9uID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKVxuY29uc3QgdmFsaWRSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJylcbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJylcbmNvbnN0IGd0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpXG5jb25zdCBsdHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKVxuY29uc3QgaW50ZXJzZWN0cyA9IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKVxuY29uc3Qgc2ltcGxpZnlSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JylcbmNvbnN0IHN1YnNldCA9IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2UsXG4gIHZhbGlkLFxuICBjbGVhbixcbiAgaW5jLFxuICBkaWZmLFxuICBtYWpvcixcbiAgbWlub3IsXG4gIHBhdGNoLFxuICBwcmVyZWxlYXNlLFxuICBjb21wYXJlLFxuICByY29tcGFyZSxcbiAgY29tcGFyZUxvb3NlLFxuICBjb21wYXJlQnVpbGQsXG4gIHNvcnQsXG4gIHJzb3J0LFxuICBndCxcbiAgbHQsXG4gIGVxLFxuICBuZXEsXG4gIGd0ZSxcbiAgbHRlLFxuICBjbXAsXG4gIGNvZXJjZSxcbiAgQ29tcGFyYXRvcixcbiAgUmFuZ2UsXG4gIHNhdGlzZmllcyxcbiAgdG9Db21wYXJhdG9ycyxcbiAgbWF4U2F0aXNmeWluZyxcbiAgbWluU2F0aXNmeWluZyxcbiAgbWluVmVyc2lvbixcbiAgdmFsaWRSYW5nZSxcbiAgb3V0c2lkZSxcbiAgZ3RyLFxuICBsdHIsXG4gIGludGVyc2VjdHMsXG4gIHNpbXBsaWZ5UmFuZ2UsXG4gIHN1YnNldCxcbiAgU2VtVmVyLFxuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IGNvbnN0YW50cy5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBSRUxFQVNFX1RZUEVTOiBjb25zdGFudHMuUkVMRUFTRV9UWVBFUyxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLnJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBNYXggc2FmZSBsZW5ndGggZm9yIGEgYnVpbGQgaWRlbnRpZmllci4gVGhlIG1heCBsZW5ndGggbWludXMgNiBjaGFyYWN0ZXJzIGZvclxuLy8gdGhlIHNob3J0ZXN0IHZlcnNpb24gd2l0aCBhIGJ1aWxkIDAuMC4wK0JVSUxELlxuY29uc3QgTUFYX1NBRkVfQlVJTERfTEVOR1RIID0gTUFYX0xFTkdUSCAtIDZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF4ID0gMTAwMFxuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBtYXAgYW5kIGFkZCBpdCB0byB0aGUgZW5kXG4gICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICBkZWxldGUgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuZGVsZXRlKGtleSlcblxuICAgIGlmICghZGVsZXRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBjYWNoZSBpcyBmdWxsLCBkZWxldGUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgaWYgKHRoaXMubWFwLnNpemUgPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLm1hcC5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0XG5jb25zdCBsb29zZU9wdGlvbiA9IE9iamVjdC5mcmVlemUoeyBsb29zZTogdHJ1ZSB9KVxuY29uc3QgZW1wdHlPcHRzID0gT2JqZWN0LmZyZWV6ZSh7IH0pXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVtcHR5T3B0c1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBsb29zZU9wdGlvblxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gIE1BWF9MRU5HVEgsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc2FmZVJlID0gZXhwb3J0cy5zYWZlUmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3Qgc2FmZVNyYyA9IGV4cG9ydHMuc2FmZVNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBMRVRURVJEQVNITlVNQkVSID0gJ1thLXpBLVowLTktXSdcblxuLy8gUmVwbGFjZSBzb21lIGdyZWVkeSByZWdleCB0b2tlbnMgdG8gcHJldmVudCByZWdleCBkb3MgaXNzdWVzLiBUaGVzZSByZWdleCBhcmVcbi8vIHVzZWQgaW50ZXJuYWxseSB2aWEgdGhlIHNhZmVSZSBvYmplY3Qgc2luY2UgYWxsIGlucHV0cyBpbiB0aGlzIGxpYnJhcnkgZ2V0XG4vLyBub3JtYWxpemVkIGZpcnN0IHRvIHRyaW0gYW5kIGNvbGxhcHNlIGFsbCBleHRyYSB3aGl0ZXNwYWNlLiBUaGUgb3JpZ2luYWxcbi8vIHJlZ2V4ZXMgYXJlIGV4cG9ydGVkIGZvciB1c2VybGFuZCBjb25zdW1wdGlvbiBhbmQgbG93ZXIgbGV2ZWwgdXNhZ2UuIEFcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2UgY291bGQgZXhwb3J0IHRoZSBzYWZlciByZWdleCBvbmx5IHdpdGggYSBub3RlIHRoYXRcbi8vIGFsbCBpbnB1dCBzaG91bGQgaGF2ZSBleHRyYSB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5jb25zdCBzYWZlUmVnZXhSZXBsYWNlbWVudHMgPSBbXG4gIFsnXFxcXHMnLCAxXSxcbiAgWydcXFxcZCcsIE1BWF9MRU5HVEhdLFxuICBbTEVUVEVSREFTSE5VTUJFUiwgTUFYX1NBRkVfQlVJTERfTEVOR1RIXSxcbl1cblxuY29uc3QgbWFrZVNhZmVSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICBmb3IgKGNvbnN0IFt0b2tlbiwgbWF4XSBvZiBzYWZlUmVnZXhSZXBsYWNlbWVudHMpIHtcbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAuc3BsaXQoYCR7dG9rZW59KmApLmpvaW4oYCR7dG9rZW59ezAsJHttYXh9fWApXG4gICAgICAuc3BsaXQoYCR7dG9rZW59K2ApLmpvaW4oYCR7dG9rZW59ezEsJHttYXh9fWApXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBzYWZlID0gbWFrZVNhZmVSZWdleCh2YWx1ZSlcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHNhZmVTcmNbaW5kZXhdID0gc2FmZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbiAgc2FmZVJlW2luZGV4XSA9IG5ldyBSZWdFeHAoc2FmZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1xcXFxkKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsIGBcXFxcZCpbYS16QS1aLV0ke0xFVFRFUkRBU0hOVU1CRVJ9KmApXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cbi8vIE5vbi1udW1iZXJpYyBpZGVudGlmaWVycyBpbmNsdWRlIG51bWJlcmljIGlkZW50aWZpZXJzIGJ1dCBjYW4gYmUgbG9uZ2VyLlxuLy8gVGhlcmVmb3JlIG5vbi1udW1iZXJpYyBpZGVudGlmaWVycyBtdXN0IGdvIGZpcnN0LlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsIGAke0xFVFRFUkRBU0hOVU1CRVJ9K2ApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0VQTEFJTicsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YClcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHtzcmNbdC5DT0VSQ0VQTEFJTl19KD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRUZVTEwnLCBzcmNbdC5DT0VSQ0VQTEFJTl0gK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pP2AgK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5CVUlMRF19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTEZVTEwnLCBzcmNbdC5DT0VSQ0VGVUxMXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCIndXNlIHN0cmljdCdcblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbmNvbnN0IG1heFNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtYXggPSBudWxsXG4gIGxldCBtYXhTViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxubW9kdWxlLmV4cG9ydHMgPSBtYXhTYXRpc2Z5aW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0ZScpXG5cbmNvbnN0IG91dHNpZGUgPSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpID0+IHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgbGV0IGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzZmllcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IGhpZ2ggPSBudWxsXG4gICAgbGV0IGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRzaWRlXG4iLCIndXNlIHN0cmljdCdcblxuLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=